
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rules: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">proto.zip/studio/validate/pkg/rules/any.go (100.0%)</option>
				
				<option value="file1">proto.zip/studio/validate/pkg/rules/conflict.go (100.0%)</option>
				
				<option value="file2">proto.zip/studio/validate/pkg/rules/constant.go (100.0%)</option>
				
				<option value="file3">proto.zip/studio/validate/pkg/rules/counter.go (100.0%)</option>
				
				<option value="file4">proto.zip/studio/validate/pkg/rules/float.go (100.0%)</option>
				
				<option value="file5">proto.zip/studio/validate/pkg/rules/inerface.go (100.0%)</option>
				
				<option value="file6">proto.zip/studio/validate/pkg/rules/int.go (100.0%)</option>
				
				<option value="file7">proto.zip/studio/validate/pkg/rules/knownKeys.go (100.0%)</option>
				
				<option value="file8">proto.zip/studio/validate/pkg/rules/number_coerce.go (100.0%)</option>
				
				<option value="file9">proto.zip/studio/validate/pkg/rules/number_rule_max.go (100.0%)</option>
				
				<option value="file10">proto.zip/studio/validate/pkg/rules/number_rule_maxexclusive.go (100.0%)</option>
				
				<option value="file11">proto.zip/studio/validate/pkg/rules/number_rule_min.go (100.0%)</option>
				
				<option value="file12">proto.zip/studio/validate/pkg/rules/number_rule_minexclusive.go (100.0%)</option>
				
				<option value="file13">proto.zip/studio/validate/pkg/rules/number_rule_values.go (100.0%)</option>
				
				<option value="file14">proto.zip/studio/validate/pkg/rules/object.go (100.0%)</option>
				
				<option value="file15">proto.zip/studio/validate/pkg/rules/paths.go (100.0%)</option>
				
				<option value="file16">proto.zip/studio/validate/pkg/rules/reftracker.go (100.0%)</option>
				
				<option value="file17">proto.zip/studio/validate/pkg/rules/rounding.go (100.0%)</option>
				
				<option value="file18">proto.zip/studio/validate/pkg/rules/rule.go (100.0%)</option>
				
				<option value="file19">proto.zip/studio/validate/pkg/rules/rule_maxlen.go (100.0%)</option>
				
				<option value="file20">proto.zip/studio/validate/pkg/rules/rule_minlen.go (100.0%)</option>
				
				<option value="file21">proto.zip/studio/validate/pkg/rules/setter.go (100.0%)</option>
				
				<option value="file22">proto.zip/studio/validate/pkg/rules/slice.go (95.3%)</option>
				
				<option value="file23">proto.zip/studio/validate/pkg/rules/string.go (100.0%)</option>
				
				<option value="file24">proto.zip/studio/validate/pkg/rules/string_coerce.go (100.0%)</option>
				
				<option value="file25">proto.zip/studio/validate/pkg/rules/string_rule_max.go (100.0%)</option>
				
				<option value="file26">proto.zip/studio/validate/pkg/rules/string_rule_maxexclusive.go (100.0%)</option>
				
				<option value="file27">proto.zip/studio/validate/pkg/rules/string_rule_min.go (100.0%)</option>
				
				<option value="file28">proto.zip/studio/validate/pkg/rules/string_rule_minexclusive.go (100.0%)</option>
				
				<option value="file29">proto.zip/studio/validate/pkg/rules/string_rule_regex.go (100.0%)</option>
				
				<option value="file30">proto.zip/studio/validate/pkg/rules/string_rule_values.go (100.0%)</option>
				
				<option value="file31">proto.zip/studio/validate/pkg/rules/wrap_any.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package rules

import (
        "context"
        "reflect"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
        "proto.zip/studio/validate/pkg/rulecontext"
)

// AnyRuleSet implements RuleSet for the "any" interface.
// AnyRuleSet is used when you don't care about the data type passed in and want to return it unaltered from the Validate method.
//
// See also: WrapAny which also implements the "any" interface and wraps another RuleSet.
type AnyRuleSet struct {
        NoConflict[any]
        required  bool
        forbidden bool
        withNil   bool
        rule      Rule[any]
        parent    *AnyRuleSet
        label     string
}

// backgroundAnyRUleSet is the main AnyRuleSet.
// Any returns this since rule sets are immutable and AnyRuleSet does not contain generics.
var backgroundAnyRuleSet AnyRuleSet = AnyRuleSet{
        label: "AnyRuleSet",
}

// Any creates a new Any rule set.
func Any() *AnyRuleSet <span class="cov10" title="34">{
        return &amp;backgroundAnyRuleSet
}</span>

// Required returns a boolean indicating if the value is allowed to be omitted when included in a nested object.
func (v *AnyRuleSet) Required() bool <span class="cov8" title="18">{
        return v.required
}</span>

// WithRequired returns a new child rule set that requires the value to be present when nested in an object.
// When a required field is missing from the input, validation fails with an error.
func (v *AnyRuleSet) WithRequired() *AnyRuleSet <span class="cov4" title="4">{
        return &amp;AnyRuleSet{
                required:  true,
                forbidden: v.forbidden,
                withNil:   v.withNil,
                parent:    v,
                label:     "WithRequired()",
        }
}</span>

// WithForbidden returns a new child rule set that requires values to be nil or omitted.
// When a value is present, validation fails with an error.
func (v *AnyRuleSet) WithForbidden() *AnyRuleSet <span class="cov2" title="2">{
        return &amp;AnyRuleSet{
                required:  v.required,
                forbidden: true,
                withNil:   v.withNil,
                parent:    v,
                label:     "WithForbidden()",
        }
}</span>

// WithNil returns a new child rule set that allows nil input values.
// When nil input is provided, validation passes and the output is set to nil (if the output type supports nil values).
// By default, nil input values return a CodeNull error.
func (v *AnyRuleSet) WithNil() *AnyRuleSet <span class="cov3" title="3">{
        return &amp;AnyRuleSet{
                required:  v.required,
                forbidden: v.forbidden,
                withNil:   true,
                parent:    v,
                label:     "WithNil()",
        }
}</span>

// Apply performs validation of a RuleSet against a value and assigns the value to the output.
// Apply returns a ValidationErrorCollection.
func (v *AnyRuleSet) Apply(ctx context.Context, input, output any) errors.ValidationErrorCollection <span class="cov9" title="27">{
        // Check if withNil is enabled and input is nil
        if handled, err := util.TrySetNilIfAllowed(ctx, v.withNil, input, output); handled </span><span class="cov5" title="5">{
                return err
        }</span>

        <span class="cov8" title="22">err := v.Evaluate(ctx, input)
        if err != nil </span><span class="cov4" title="4">{
                return err
        }</span>

        // Ensure output is a pointer
        <span class="cov8" title="18">rv := reflect.ValueOf(output)
        if rv.Kind() != reflect.Ptr || rv.IsNil() </span><span class="cov3" title="3">{
                return errors.Collection(
                        errors.Errorf(errors.CodeInternal, ctx, "Output must be a non-nil pointer"),
                )
        }</span>

        // Get the element the pointer points to
        <span class="cov7" title="15">elem := rv.Elem()

        // Convert input to reflect.Value
        inputValue := reflect.ValueOf(input)

        // Check if the input can be assigned to the output
        if inputValue.Type().AssignableTo(elem.Type()) </span><span class="cov7" title="14">{
                elem.Set(inputValue)
                return nil
        }</span>

        <span class="cov1" title="1">return errors.Collection(
                errors.Errorf(errors.CodeInternal, ctx, "Cannot assign %T to %T", input, output),
        )</span>
}

// Evaluate performs validation of a RuleSet against a value and returns a ValidationErrorCollection.
// Evaluate calls wrapped rules before any rules added directly to the AnyRuleSet.
func (v *AnyRuleSet) Evaluate(ctx context.Context, value any) errors.ValidationErrorCollection <span class="cov9" title="23">{
        if v.forbidden </span><span class="cov1" title="1">{
                return errors.Collection(errors.Errorf(errors.CodeForbidden, ctx, "value is not allowed"))
        }</span>

        <span class="cov8" title="22">allErrors := errors.Collection()

        currentRuleSet := v
        ctx = rulecontext.WithRuleSet(ctx, v)

        for currentRuleSet != nil </span><span class="cov9" title="31">{
                if currentRuleSet.rule != nil </span><span class="cov6" title="9">{
                        err := currentRuleSet.rule.Evaluate(ctx, value)
                        if err != nil </span><span class="cov4" title="4">{
                                allErrors = append(allErrors, err...)
                        }</span>
                }

                <span class="cov9" title="31">currentRuleSet = currentRuleSet.parent</span>
        }

        <span class="cov8" title="22">if len(allErrors) != 0 </span><span class="cov4" title="4">{
                return allErrors
        }</span> else<span class="cov8" title="18"> {
                return nil
        }</span>
}

// WithRule returns a new child rule set that applies a custom validation rule.
// The custom rule is evaluated during validation and any errors it returns are included in the validation result.
func (v *AnyRuleSet) WithRule(rule Rule[any]) *AnyRuleSet <span class="cov6" title="8">{
        return &amp;AnyRuleSet{
                required:  v.required,
                forbidden: v.forbidden,
                withNil:   v.withNil,
                rule:      rule,
                parent:    v,
        }
}</span>

// WithRuleFunc returns a new child rule set that applies a custom validation function.
// The custom function is evaluated during validation and any errors it returns are included in the validation result.
func (v *AnyRuleSet) WithRuleFunc(rule RuleFunc[any]) *AnyRuleSet <span class="cov5" title="5">{
        return v.WithRule(rule)
}</span>

// Any returns the current rule set.
func (v *AnyRuleSet) Any() RuleSet[any] <span class="cov1" title="1">{
        return v
}</span>

// String returns a string representation of the rule set suitable for debugging.
func (ruleSet *AnyRuleSet) String() string <span class="cov6" title="8">{
        label := ruleSet.label

        if label == "" </span><span class="cov1" title="1">{
                if ruleSet.rule != nil </span><span class="cov1" title="1">{
                        label = ruleSet.rule.String()
                }</span>
        }

        <span class="cov6" title="8">if ruleSet.parent != nil </span><span class="cov3" title="3">{
                return ruleSet.parent.String() + "." + label
        }</span>
        <span class="cov5" title="5">return label</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package rules

// NoConflict is a helper struct that implements the Conflict method to always return false.
// NoConflict can be embedded in rule sets to indicate that they never conflict with other rules.
type NoConflict[T any] struct {
}

func (_ NoConflict[T]) Conflict(_ Rule[T]) bool <span class="cov8" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package rules

import (
        "context"
        "fmt"
        "reflect"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
)

type constCache[T comparable] map[T]*ConstantRuleSet[T]

var constCacheMap map[any]any

// ConstantRuleSet implements RuleSet that returns an error for
// any value that does not match the constant.
//
// This is primarily used for conditional validation. To test a constant of a specific
// type it is usually best to use that type.
type ConstantRuleSet[T comparable] struct {
        required bool
        withNil  bool
        value    T
        empty    T // Leave this empty
}

// Constant creates a new Constant rule set for the specified value.
// Constant returns the same Rule Set when called multiple times with the same value.
func Constant[T comparable](value T) *ConstantRuleSet[T] <span class="cov9" title="247">{
        var empty T
        var typedCache constCache[T]

        if constCacheMap == nil </span><span class="cov1" title="1">{
                constCacheMap = make(map[any]any)
                typedCache = make(map[T]*ConstantRuleSet[T])
                constCacheMap[empty] = typedCache
        }</span> else<span class="cov9" title="246"> if tmp, ok := constCacheMap[empty]; ok </span><span class="cov9" title="244">{
                typedCache = tmp.(constCache[T])
        }</span> else<span class="cov2" title="2"> {
                typedCache = make(map[T]*ConstantRuleSet[T])
                constCacheMap[empty] = typedCache
        }</span>

        <span class="cov9" title="247">if val, ok := typedCache[value]; ok </span><span class="cov8" title="216">{
                return val
        }</span>

        <span class="cov6" title="31">typedCache[value] = &amp;ConstantRuleSet[T]{
                value: value,
        }
        return typedCache[value]</span>
}

// Required returns a boolean indicating if the value is allowed to be omitted when included in a nested object.
func (ruleSet *ConstantRuleSet[T]) Required() bool <span class="cov4" title="8">{
        return ruleSet.required
}</span>

// WithRequired returns a new child rule set that requires the value to be present when nested in an object.
// When a required field is missing from the input, validation fails with an error.
func (ruleSet *ConstantRuleSet[T]) WithRequired() *ConstantRuleSet[T] <span class="cov3" title="6">{
        if ruleSet.required </span><span class="cov1" title="1">{
                return ruleSet
        }</span>

        <span class="cov3" title="5">return &amp;ConstantRuleSet[T]{
                value:    ruleSet.value,
                required: true,
                withNil:  ruleSet.withNil,
        }</span>
}

// WithNil returns a new child rule set that allows nil input values.
// When nil input is provided, validation passes and the output is set to nil (if the output type supports nil values).
// By default, nil input values return a CodeNull error.
func (ruleSet *ConstantRuleSet[T]) WithNil() *ConstantRuleSet[T] <span class="cov2" title="2">{
        return &amp;ConstantRuleSet[T]{
                value:    ruleSet.value,
                required: ruleSet.required,
                withNil:  true,
        }
}</span>

// Apply validates a RuleSet against an input value and assigns the validated value to output.
// Apply returns a ValidationErrorCollection.
func (ruleSet *ConstantRuleSet[T]) Apply(ctx context.Context, input, output any) errors.ValidationErrorCollection <span class="cov4" title="15">{
        // Check if withNil is enabled and input is nil
        if handled, err := util.TrySetNilIfAllowed(ctx, ruleSet.withNil, input, output); handled </span><span class="cov2" title="3">{
                return err
        }</span>

        // Attempt to coerce input to type T.
        <span class="cov4" title="12">v, ok := input.(T)
        if !ok </span><span class="cov1" title="1">{
                // Return a coercion error if input is not of type T.
                return errors.Collection(errors.NewCoercionError(ctx, reflect.TypeOf(ruleSet.empty).String(), reflect.TypeOf(input).String()))
        }</span>

        // Ensure the output is assignable to the coerced value.
        <span class="cov4" title="11">outVal := reflect.ValueOf(output)
        if outVal.Kind() != reflect.Ptr || outVal.IsNil() || !reflect.ValueOf(v).Type().AssignableTo(outVal.Elem().Type()) </span><span class="cov3" title="4">{
                // Return an error if the output is not assignable.
                return errors.Collection(errors.Errorf(errors.CodeInternal, ctx, "Cannot assign %T to %T", input, output))
        }</span>

        // Assign the validated value to the output.
        <span class="cov3" title="7">outVal.Elem().Set(reflect.ValueOf(v))

        // Evaluate the RuleSet and return any validation errors.
        return ruleSet.Evaluate(ctx, v)</span>
}

// Evaluate performs validation of a RuleSet against a value and returns any errors.
func (ruleSet *ConstantRuleSet[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov8" title="132">{
        if value != ruleSet.value </span><span class="cov7" title="66">{
                return errors.Collection(errors.Errorf(errors.CodePattern, ctx, "value does not match"))
        }</span>
        <span class="cov7" title="66">return nil</span>
}

// Conflict returns true for all rules since by definition no rule can be a superset of a constant rule.
func (ruleSet *ConstantRuleSet[T]) Conflict(other Rule[T]) bool <span class="cov2" title="2">{
        return true
}</span>

// Any returns the current rule set wrapped as a RuleSet[any].
func (ruleSet *ConstantRuleSet[T]) Any() RuleSet[any] <span class="cov3" title="6">{
        return WrapAny[T](ruleSet)
}</span>

// String returns a string representation of the rule set suitable for debugging.
func (ruleSet *ConstantRuleSet[T]) String() string <span class="cov2" title="2">{
        str := fmt.Sprintf(`ConstantRuleSet(%v)`, ruleSet.value)
        if ruleSet.required </span><span class="cov1" title="1">{
                return str + ".WithRequired()"
        }</span>
        <span class="cov1" title="1">return str</span>
}

// Value returns the constant value in the correct type.
func (ruleSet *ConstantRuleSet[T]) Value() T <span class="cov10" title="458">{
        return ruleSet.value
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package rules

import (
        "context"
        "fmt"
        "sync"
)

// counter is used for evaluating rules and keeps track of how many rules
// are remaining for each key.
type counter struct {
        mu    sync.RWMutex // mu protects concurrent access to count.
        count int          // count holds the current value of the counter.
        cond  *sync.Cond   // cond is used to signal when the counter reaches 0.
}

// newCounter initializes and returns a new counter object.
func newCounter() *counter <span class="cov9" title="111">{
        c := &amp;counter{}
        c.cond = sync.NewCond(&amp;c.mu)
        return c
}</span>

// Increment safely increases the counter by 1.
func (c *counter) Increment() <span class="cov9" title="119">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.count++
}</span>

// Lock locks the counter for writing.
func (c *counter) Lock() <span class="cov10" title="120">{
        c.mu.Lock()
}</span>

// Unlock decreases the counter by 1 and then unlocks it.
// If the counter reaches 0, it broadcasts to any waiting goroutines.
func (c *counter) Unlock() <span class="cov10" title="120">{
        c.count--
        count := c.count
        c.mu.Unlock()

        if count == 0 </span><span class="cov9" title="111">{
                c.cond.Broadcast()
        }</span> else<span class="cov5" title="9"> if count &lt; 0 </span><span class="cov1" title="1">{
                panic(fmt.Errorf("negative rule counter: %d", count))</span>
        }

}

// Wait waits for the counter to reach 0.
func (c *counter) Wait() <span class="cov4" title="6">{
        c.mu.Lock()
        defer c.mu.Unlock()
        for c.count &gt; 0 </span><span class="cov3" title="4">{
                c.cond.Wait()
        }</span>
}

// counterSet manages a thread-safe collection of counters, each associated with a unique key.
type counterSet[TK comparable] struct {
        mu       sync.RWMutex    // mu protects concurrent access to counters.
        counters map[TK]*counter // counters holds the collection of counters.
}

// newCounterSet initializes and returns a new counterSet object.
func newCounterSet[TK comparable]() *counterSet[TK] <span class="cov9" title="91">{
        return &amp;counterSet[TK]{
                counters: make(map[TK]*counter),
        }
}</span>

// Increment safely increases the counter associated with the given key by 1.
// If a counter doesn't exist for the key, it creates one.
func (cs *counterSet[TK]) Increment(key TK) <span class="cov9" title="118">{
        cs.mu.Lock()
        defer cs.mu.Unlock()

        if _, exists := cs.counters[key]; !exists </span><span class="cov9" title="110">{
                cs.counters[key] = newCounter()
        }</span>
        <span class="cov9" title="118">cs.counters[key].Increment()</span>
}

// Lock locks the counter for a specific key for writing.
func (cs *counterSet[TK]) Lock(key TK) <span class="cov9" title="118">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()

        if _, exists := cs.counters[key]; exists </span><span class="cov9" title="118">{
                cs.counters[key].Lock()
        }</span>
}

// Unlock unlocks the counter for a specific key for writing.
func (cs *counterSet[TK]) Unlock(key TK) <span class="cov9" title="118">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()

        if _, exists := cs.counters[key]; exists </span><span class="cov9" title="118">{
                cs.counters[key].Unlock()
        }</span>
}

// Wait waits for the counters associated with the provided key rules to reach 0.
// If a rule doesn't have an associated counter, it simply moves on to the next rule.
func (cs *counterSet[TK]) Wait(keyRules ...Rule[TK]) <span class="cov4" title="6">{
        ctx := context.Background()

        cs.mu.RLock()
        for key, c := range cs.counters </span><span class="cov5" title="12">{
                for _, rule := range keyRules </span><span class="cov5" title="12">{
                        if rule.Evaluate(ctx, key) == nil </span><span class="cov4" title="6">{
                                c.Wait()
                        }</span>
                }
        }
        <span class="cov4" title="6">cs.mu.RUnlock()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package rules

import (
        "context"
        "math"
        "reflect"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
)

var baseFloat32 FloatRuleSet[float32] = FloatRuleSet[float32]{
        outputPrecision: -1, // -1 means not set
        label:           "FloatRuleSet[float32]",
}

var baseFloat64 FloatRuleSet[float64] = FloatRuleSet[float64]{
        outputPrecision: -1, // -1 means not set
        label:           "FloatRuleSet[float64]",
}

type floating interface {
        float64 | float32
}

// Implementation of RuleSet for floats.
type FloatRuleSet[T floating] struct {
        NoConflict[T]
        strict          bool
        rule            Rule[T]
        required        bool
        withNil         bool
        parent          *FloatRuleSet[T]
        rounding        Rounding
        precision       int // Precision for rounding (used with WithRounding)
        outputPrecision int // Precision for string output (-1 means not set, &gt;= 0 means fixed output)
        label           string
}

// Float32 creates a new float32 RuleSet.
func Float32() *FloatRuleSet[float32] <span class="cov4" title="9">{
        return &amp;baseFloat32
}</span>

// Float64 creates a new float64 RuleSet.
func Float64() *FloatRuleSet[float64] <span class="cov7" title="80">{
        return &amp;baseFloat64
}</span>

// WithStrict returns a new child RuleSet that disables type coercion.
// When strict mode is enabled, validation only succeeds if the value is already the correct type.
//
// With number types, any type will work in strict mode as long as it can be converted
// deterministically and without loss.
func (v *FloatRuleSet[T]) WithStrict() *FloatRuleSet[T] <span class="cov2" title="2">{
        return &amp;FloatRuleSet[T]{
                strict:          true,
                parent:          v,
                required:        v.required,
                withNil:         v.withNil,
                rounding:        v.rounding,
                precision:       v.precision,
                outputPrecision: v.outputPrecision,
                label:           "WithStrict()",
        }
}</span>

// Required returns a boolean indicating if the value is allowed to be omitted when included in a nested object.
func (v *FloatRuleSet[T]) Required() bool <span class="cov6" title="30">{
        return v.required
}</span>

// WithRequired returns a new child rule set that requires the value to be present when nested in an object.
// When a required field is missing from the input, validation fails with an error.
func (v *FloatRuleSet[T]) WithRequired() *FloatRuleSet[T] <span class="cov2" title="3">{
        return &amp;FloatRuleSet[T]{
                strict:          v.strict,
                parent:          v,
                required:        true,
                withNil:         v.withNil,
                rounding:        v.rounding,
                precision:       v.precision,
                outputPrecision: v.outputPrecision,
                label:           "WithRequired()",
        }
}</span>

// WithNil returns a new child rule set that allows nil input values.
// When nil input is provided, validation passes and the output is set to nil (if the output type supports nil values).
// By default, nil input values return a CodeNull error.
func (v *FloatRuleSet[T]) WithNil() *FloatRuleSet[T] <span class="cov2" title="2">{
        return &amp;FloatRuleSet[T]{
                strict:          v.strict,
                parent:          v,
                required:        v.required,
                withNil:         true,
                rounding:        v.rounding,
                precision:       v.precision,
                outputPrecision: v.outputPrecision,
                label:           "WithNil()",
        }
}</span>

// Apply performs validation of a RuleSet against a value and assigns the result to the output parameter.
// Apply returns a ValidationErrorCollection if any validation errors occur.
func (v *FloatRuleSet[T]) Apply(ctx context.Context, input any, output any) errors.ValidationErrorCollection <span class="cov9" title="250">{
        // Check if withNil is enabled and input is nil
        if handled, err := util.TrySetNilIfAllowed(ctx, v.withNil, input, output); handled </span><span class="cov2" title="3">{
                return err
        }</span>

        // Ensure output is a non-nil pointer
        <span class="cov9" title="247">outputVal := reflect.ValueOf(output)
        if outputVal.Kind() != reflect.Ptr || outputVal.IsNil() </span><span class="cov2" title="3">{
                return errors.Collection(errors.Errorf(
                        errors.CodeInternal, ctx, "Output must be a non-nil pointer",
                ))
        }</span>

        // Attempt to coerce the input value to the correct float type
        <span class="cov9" title="244">floatval, validationErr := v.coerceFloat(input, ctx)
        if validationErr != nil </span><span class="cov6" title="33">{
                return errors.Collection(validationErr)
        }</span>

        // Apply rounding if specified
        <span class="cov9" title="211">if v.rounding != RoundingNone </span><span class="cov7" title="101">{
                mul := math.Pow10(v.precision)
                tempFloatval := float64(floatval) * mul

                switch v.rounding </span>{
                case RoundingDown:<span class="cov5" title="18">
                        tempFloatval = math.Floor(tempFloatval)</span>
                case RoundingUp:<span class="cov5" title="17">
                        tempFloatval = math.Ceil(tempFloatval)</span>
                case RoundingHalfUp:<span class="cov5" title="25">
                        tempFloatval = math.Round(tempFloatval)</span>
                case RoundingHalfEven:<span class="cov6" title="41">
                        tempFloatval = math.RoundToEven(tempFloatval)</span>
                }

                <span class="cov7" title="101">tempFloatval /= mul
                floatval = T(tempFloatval)</span>
        }

        // Handle setting the value in output
        <span class="cov9" title="211">outputElem := outputVal.Elem()

        var assignable bool

        // Format the float as a string with the appropriate precision
        strVal := formatFloat(v, floatval)

        // Check if output is a string type
        if outputElem.Kind() == reflect.String </span><span class="cov6" title="38">{
                outputElem.SetString(strVal)
                assignable = true
        }</span> else<span class="cov8" title="173"> if outputElem.Kind() == reflect.Ptr &amp;&amp; outputElem.Type().Elem().Kind() == reflect.String </span><span class="cov3" title="7">{
                // Handle pointer to string
                if outputElem.IsNil() </span><span class="cov3" title="4">{
                        newStrPtr := reflect.New(outputElem.Type().Elem())
                        newStrPtr.Elem().SetString(strVal)
                        outputElem.Set(newStrPtr)
                }</span> else<span class="cov2" title="3"> {
                        outputElem.Elem().SetString(strVal)
                }</span>
                <span class="cov3" title="7">assignable = true</span>
        } else<span class="cov8" title="166"> if (outputElem.Kind() == reflect.Interface &amp;&amp; outputElem.IsNil()) ||
                (outputElem.Kind() == reflect.Float32 || outputElem.Kind() == reflect.Float64 ||
                        outputElem.Type().AssignableTo(reflect.TypeOf(floatval))) </span><span class="cov8" title="165">{

                // If output is a nil interface, or an assignable type, set it directly to the new float value
                outputElem.Set(reflect.ValueOf(floatval))
                assignable = true
        }</span>

        // If the types are incompatible, return an error
        <span class="cov9" title="211">if !assignable </span><span class="cov1" title="1">{
                return errors.Collection(errors.Errorf(
                        errors.CodeInternal, ctx, "Cannot assign %T to %T", floatval, outputElem.Interface(),
                ))
        }</span>

        <span class="cov9" title="210">allErrors := errors.Collection()

        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov10" title="382">{
                if currentRuleSet.rule != nil </span><span class="cov6" title="48">{
                        if err := currentRuleSet.rule.Evaluate(ctx, floatval); err != nil </span><span class="cov5" title="16">{
                                allErrors = append(allErrors, err...)
                        }</span>
                }
        }

        <span class="cov9" title="210">if len(allErrors) != 0 </span><span class="cov5" title="16">{
                return allErrors
        }</span>
        <span class="cov8" title="194">return nil</span>
}

// Evaluate performs validation of a RuleSet against a float value and returns a ValidationErrorCollection.
func (v *FloatRuleSet[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov2" title="2">{
        var out T
        return v.Apply(ctx, value, &amp;out)
}</span>

// noConflict returns the new array rule set with all conflicting rules removed.
// Does not mutate the existing rule sets.
func (ruleSet *FloatRuleSet[T]) noConflict(rule Rule[T]) *FloatRuleSet[T] <span class="cov6" title="31">{
        if ruleSet.rule != nil </span><span class="cov4" title="12">{

                // Conflicting rules, skip this and return the parent
                if rule.Conflict(ruleSet.rule) </span><span class="cov3" title="4">{
                        return ruleSet.parent.noConflict(rule)
                }</span>

        }

        <span class="cov5" title="27">if ruleSet.parent == nil </span><span class="cov5" title="19">{
                return ruleSet
        }</span>

        <span class="cov4" title="8">newParent := ruleSet.parent.noConflict(rule)

        if newParent == ruleSet.parent </span><span class="cov3" title="4">{
                return ruleSet
        }</span>

        <span class="cov3" title="4">return &amp;FloatRuleSet[T]{
                strict:          ruleSet.strict,
                rule:            ruleSet.rule,
                required:        ruleSet.required,
                withNil:         ruleSet.withNil,
                parent:          newParent,
                rounding:        ruleSet.rounding,
                precision:       ruleSet.precision,
                outputPrecision: ruleSet.outputPrecision,
                label:           ruleSet.label,
        }</span>
}

// WithRule returns a new child rule set that applies a custom validation rule.
// The custom rule is evaluated during validation and any errors it returns are included in the validation result.
func (ruleSet *FloatRuleSet[T]) WithRule(rule Rule[T]) *FloatRuleSet[T] <span class="cov5" title="19">{
        return &amp;FloatRuleSet[T]{
                strict:          ruleSet.strict,
                parent:          ruleSet.noConflict(rule),
                rule:            rule,
                required:        ruleSet.required,
                withNil:         ruleSet.withNil,
                rounding:        ruleSet.rounding,
                precision:       ruleSet.precision,
                outputPrecision: ruleSet.outputPrecision,
        }
}</span>

// WithRuleFunc returns a new child rule set that applies a custom validation function.
// The custom function is evaluated during validation and any errors it returns are included in the validation result.
func (v *FloatRuleSet[T]) WithRuleFunc(rule RuleFunc[T]) *FloatRuleSet[T] <span class="cov2" title="2">{
        return v.WithRule(rule)
}</span>

// Any returns a new RuleSet that wraps the number RuleSet in an Any rule set
// which can then be used in nested validation.
func (v *FloatRuleSet[T]) Any() RuleSet[any] <span class="cov6" title="28">{
        return WrapAny[T](v)
}</span>

// typeName returns the name for the target integer type.
// Used for error message formatting.
func (v *FloatRuleSet[T]) typeName() string <span class="cov6" title="31">{
        return reflect.ValueOf(*new(T)).Kind().String()
}</span>

// String returns a string representation of the rule set suitable for debugging.
func (ruleSet *FloatRuleSet[T]) String() string <span class="cov6" title="32">{
        label := ruleSet.label

        if label == "" &amp;&amp; ruleSet.rule != nil </span><span class="cov5" title="16">{
                label = ruleSet.rule.String()
        }</span>

        <span class="cov6" title="32">if ruleSet.parent != nil </span><span class="cov5" title="20">{
                return ruleSet.parent.String() + "." + label
        }</span>
        <span class="cov4" title="12">return label</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package rules

import (
        "context"
        "fmt"
        "reflect"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
        "proto.zip/studio/validate/pkg/rulecontext"
)

// InterfaceRuleSet implements RuleSet for the a generic interface.
type InterfaceRuleSet[T any] struct {
        NoConflict[T]
        required bool
        withNil  bool
        rule     Rule[T]
        parent   *InterfaceRuleSet[T]
        label    string
        cast     func(ctx context.Context, value any) (T, errors.ValidationErrorCollection)
        empty    T // leave empty
}

// Interface creates a new Interface rule set.
func Interface[T any]() *InterfaceRuleSet[T] <span class="cov7" title="13">{
        return &amp;InterfaceRuleSet[T]{
                label: fmt.Sprintf("InterfaceRuleSet[%s]", reflect.TypeOf(new(T)).Elem().Name()),
        }
}</span>

// WithCast creates a new Interface rule set that has the set cast function.
// The cast function should take "any" and return a value of the appropriate interface type.
// Run will always try to directly cast the value. Adding a function is useful for when the
// value may need to be wrapped in another type in order to satisfy the interface.
//
// Cast functions are stacking, You may call this function as many times as you need in order
// to cast from different type. Newly defined cast functions take priority. Execution will stop
// at the first function to return a non-nil value or an error collection.
//
// A third boolean return value is added to differentiate between a successful cast to a nil value
// and
func (v *InterfaceRuleSet[T]) WithCast(fn func(ctx context.Context, value any) (T, errors.ValidationErrorCollection)) *InterfaceRuleSet[T] <span class="cov5" title="5">{
        return &amp;InterfaceRuleSet[T]{
                required: v.required,
                withNil:  v.withNil,
                parent:   v,
                cast:     fn,
                label:    "WithCast(...)",
        }
}</span>

// Required returns a boolean indicating if the value is allowed to be omitted when included in a nested object.
func (v *InterfaceRuleSet[T]) Required() bool <span class="cov8" title="16">{
        return v.required
}</span>

// WithRequired returns a new child rule set that requires the value to be present when nested in an object.
// When a required field is missing from the input, validation fails with an error.
func (v *InterfaceRuleSet[T]) WithRequired() *InterfaceRuleSet[T] <span class="cov5" title="5">{
        if v.required </span><span class="cov1" title="1">{
                return v
        }</span>

        <span class="cov4" title="4">return &amp;InterfaceRuleSet[T]{
                required: true,
                withNil:  v.withNil,
                parent:   v,
                label:    "WithRequired()",
        }</span>
}

// WithNil returns a new child rule set that allows nil input values.
// When nil input is provided, validation passes and the output is set to nil (if the output type supports nil values).
// By default, nil input values return a CodeNull error.
func (v *InterfaceRuleSet[T]) WithNil() *InterfaceRuleSet[T] <span class="cov2" title="2">{
        return &amp;InterfaceRuleSet[T]{
                required: v.required,
                withNil:  true,
                cast:     v.cast,
                parent:   v,
                label:    "WithNil()",
        }
}</span>

// Apply performs a validation of a RuleSet against a value and assigns the result to the output parameter.
// It returns a ValidationErrorCollection if any validation errors occur.
func (ruleSet *InterfaceRuleSet[T]) Apply(ctx context.Context, input any, output any) errors.ValidationErrorCollection <span class="cov9" title="25">{
        // Check if withNil is enabled and input is nil
        if handled, err := util.TrySetNilIfAllowed(ctx, ruleSet.withNil, input, output); handled </span><span class="cov3" title="3">{
                return err
        }</span>

        // Ensure output is a pointer
        <span class="cov9" title="22">outputVal := reflect.ValueOf(output)
        if outputVal.Kind() != reflect.Ptr || outputVal.IsNil() </span><span class="cov3" title="3">{
                return errors.Collection(errors.Errorf(
                        errors.CodeInternal, ctx, "Output must be a non-nil pointer",
                ))
        }</span>

        // Attempt to cast the input value directly to the expected type T
        <span class="cov8" title="19">if v, ok := input.(T); ok </span><span class="cov6" title="7">{
                inputValue := reflect.ValueOf(v)
                if !inputValue.Type().AssignableTo(outputVal.Elem().Type()) </span><span class="cov1" title="1">{
                        return errors.Collection(errors.Errorf(
                                errors.CodeInternal, ctx, "Cannot assign `%T` to `%T`", input, output,
                        ))
                }</span>
                <span class="cov5" title="6">outputVal.Elem().Set(inputValue)
                return ruleSet.Evaluate(ctx, v)</span>
        }

        // Iterate through the rule sets to find a valid cast function
        <span class="cov7" title="12">for curRuleSet := ruleSet; curRuleSet != nil; curRuleSet = curRuleSet.parent </span><span class="cov8" title="15">{
                if curRuleSet.cast != nil </span><span class="cov7" title="12">{
                        if v, errs := curRuleSet.cast(ctx, input); any(v) != nil || errs != nil </span><span class="cov6" title="9">{
                                if errs != nil </span><span class="cov1" title="1">{
                                        return errs
                                }</span>
                                <span class="cov6" title="8">outputVal.Elem().Set(reflect.ValueOf(v))
                                return ruleSet.Evaluate(ctx, v)</span>
                        }
                }
        }

        // If casting fails, return a coercion error
        <span class="cov3" title="3">return errors.Collection(
                errors.NewCoercionError(
                        ctx,
                        reflect.TypeOf(new(T)).Elem().Name(),
                        reflect.ValueOf(input).Kind().String(),
                ),
        )</span>
}

// Evaluate performs a validation of a RuleSet against all the defined rules.
func (v *InterfaceRuleSet[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov8" title="15">{
        allErrors := errors.Collection()

        currentRuleSet := v
        ctx = rulecontext.WithRuleSet(ctx, v)

        for currentRuleSet != nil </span><span class="cov10" title="30">{
                if currentRuleSet.rule != nil </span><span class="cov4" title="4">{
                        err := currentRuleSet.rule.Evaluate(ctx, value)
                        if err != nil </span><span class="cov3" title="3">{
                                allErrors = append(allErrors, err...)
                        }</span>
                }

                <span class="cov10" title="30">currentRuleSet = currentRuleSet.parent</span>
        }

        <span class="cov8" title="15">if len(allErrors) != 0 </span><span class="cov3" title="3">{
                return allErrors
        }</span> else<span class="cov7" title="12"> {
                return nil
        }</span>
}

// WithRule returns a new child rule set that applies a custom validation rule.
// The custom rule is evaluated during validation and any errors it returns are included in the validation result.
//
// Use this when implementing custom rules.
func (v *InterfaceRuleSet[T]) WithRule(rule Rule[T]) *InterfaceRuleSet[T] <span class="cov5" title="5">{
        return &amp;InterfaceRuleSet[T]{
                required: v.required,
                withNil:  v.withNil,
                cast:     v.cast,
                rule:     rule,
                parent:   v,
        }
}</span>

// WithRuleFunc returns a new child rule set that applies a custom validation function.
// The custom function is evaluated during validation and any errors it returns are included in the validation result.
//
// Use this when implementing custom rules.
func (v *InterfaceRuleSet[T]) WithRuleFunc(rule RuleFunc[T]) *InterfaceRuleSet[T] <span class="cov3" title="3">{
        return v.WithRule(rule)
}</span>

// Interface is an identity function for this implementation and returns the current rule set.
func (v *InterfaceRuleSet[T]) Any() RuleSet[any] <span class="cov7" title="14">{
        return WrapAny[T](v)
}</span>

// String returns a string representation of the rule set suitable for debugging.
func (ruleSet *InterfaceRuleSet[T]) String() string <span class="cov4" title="4">{
        label := ruleSet.label

        if label == "" </span><span class="cov1" title="1">{
                if ruleSet.rule != nil </span><span class="cov1" title="1">{
                        label = ruleSet.rule.String()
                }</span>
        }

        <span class="cov4" title="4">if ruleSet.parent != nil </span><span class="cov2" title="2">{
                return ruleSet.parent.String() + "." + label
        }</span>
        <span class="cov2" title="2">return label</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package rules

import (
        "context"
        "fmt"
        "reflect"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
)

var baseInt IntRuleSet[int] = IntRuleSet[int]{
        base:  10,
        label: "IntRuleSet[int]",
}

var baseUint IntRuleSet[uint] = IntRuleSet[uint]{
        base:  10,
        label: "IntRuleSet[uint]",
}

var baseInt8 IntRuleSet[int8] = IntRuleSet[int8]{
        base:  10,
        label: "IntRuleSet[int8]",
}

var baseUint8 IntRuleSet[uint8] = IntRuleSet[uint8]{
        base:  10,
        label: "IntRuleSet[uint8]",
}

var baseInt16 IntRuleSet[int16] = IntRuleSet[int16]{
        base:  10,
        label: "IntRuleSet[int16]",
}

var baseUint16 IntRuleSet[uint16] = IntRuleSet[uint16]{
        base:  10,
        label: "IntRuleSet[uint16]",
}

var baseInt32 IntRuleSet[int32] = IntRuleSet[int32]{
        base:  10,
        label: "IntRuleSet[int32]",
}

var baseUint32 IntRuleSet[uint32] = IntRuleSet[uint32]{
        base:  10,
        label: "IntRuleSet[uint32]",
}

var baseInt64 IntRuleSet[int64] = IntRuleSet[int64]{
        base:  10,
        label: "IntRuleSet[int64]",
}

var baseUint64 IntRuleSet[uint64] = IntRuleSet[uint64]{
        base:  10,
        label: "IntRuleSet[uint64]",
}

type integer interface {
        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr | ~int | ~int8 | ~int16 | ~int32 | ~int64
}

// Implementation of RuleSet for integers.
type IntRuleSet[T integer] struct {
        NoConflict[T]
        strict   bool
        base     int
        rule     Rule[T]
        required bool
        withNil  bool
        parent   *IntRuleSet[T]
        rounding Rounding
        label    string
}

// Int creates a new integer RuleSet.
func Int() *IntRuleSet[int] <span class="cov8" title="129">{
        return &amp;baseInt
}</span>

// Uint creates a new unsigned integer RuleSet.
func Uint() *IntRuleSet[uint] <span class="cov2" title="2">{
        return &amp;baseUint
}</span>

// Int8 creates a new 8 bit integer RuleSet.
func Int8() *IntRuleSet[int8] <span class="cov4" title="10">{
        return &amp;baseInt8
}</span>

// Uint8 creates a new unsigned 8 bit integer RuleSet.
func Uint8() *IntRuleSet[uint8] <span class="cov3" title="5">{
        return &amp;baseUint8
}</span>

// Int16 creates a new 16 bit integer RuleSet.
func Int16() *IntRuleSet[int16] <span class="cov2" title="2">{
        return &amp;baseInt16
}</span>

// Uint16 creates a new unsigned 16 bit integer RuleSet.
func Uint16() *IntRuleSet[uint16] <span class="cov2" title="2">{
        return &amp;baseUint16
}</span>

// Int32 creates a new 32 bit integer RuleSet.
func Int32() *IntRuleSet[int32] <span class="cov2" title="2">{
        return &amp;baseInt32
}</span>

// Uint32 creates a new unsigned 32 bit integer RuleSet.
func Uint32() *IntRuleSet[uint32] <span class="cov2" title="2">{
        return &amp;baseUint32
}</span>

// Int64 creates a new int64 RuleSet.
func Int64() *IntRuleSet[int64] <span class="cov2" title="2">{
        return &amp;baseInt64
}</span>

// Uint64 creates a new unsigned 64 bit integer RuleSet.
func Uint64() *IntRuleSet[uint64] <span class="cov2" title="2">{
        return &amp;baseUint64
}</span>

// WithStrict returns a new child RuleSet that disables type coercion.
// When strict mode is enabled, validation only succeeds if the value is already the correct type.
//
// With number types, any type will work in strict mode as long as it can be converted
// deterministically and without loss.
func (v *IntRuleSet[T]) WithStrict() *IntRuleSet[T] <span class="cov2" title="2">{
        return &amp;IntRuleSet[T]{
                strict:   true,
                parent:   v,
                base:     v.base,
                required: v.required,
                withNil:  v.withNil,
                rounding: v.rounding,
                label:    "WithStrict()",
        }
}</span>

// WithBase returns a new child rule set that uses the specified base for string-to-number conversion and number-to-string conversion.
// The base determines how numeric strings are parsed from input (e.g., base 16 for hexadecimal) and how integers are formatted to strings in output.
// When outputting to a string type, the integer will be formatted using the specified base (e.g., base 16 will format as hexadecimal like "beef").
// The base has no effect if the RuleSet is strict since strict mode disables type conversion.
//
// The default is base 10.
func (v *IntRuleSet[T]) WithBase(base int) *IntRuleSet[T] <span class="cov4" title="9">{
        return &amp;IntRuleSet[T]{
                strict:   v.strict,
                parent:   v,
                base:     base,
                required: v.required,
                withNil:  v.withNil,
                rounding: v.rounding,
                label:    fmt.Sprintf("WithBase(%d)", base),
        }
}</span>

// Required returns a boolean indicating if the value is allowed to be omitted when included in a nested object.
func (v *IntRuleSet[T]) Required() bool <span class="cov8" title="115">{
        return v.required
}</span>

// WithRequired returns a new child rule set that requires the value to be present when nested in an object.
// When a required field is missing from the input, validation fails with an error.
func (v *IntRuleSet[T]) WithRequired() *IntRuleSet[T] <span class="cov3" title="4">{
        return &amp;IntRuleSet[T]{
                strict:   v.strict,
                parent:   v,
                base:     v.base,
                required: true,
                withNil:  v.withNil,
                rounding: v.rounding,
                label:    "WithRequired()",
        }
}</span>

// WithNil returns a new child rule set that allows nil input values.
// When nil input is provided, validation passes and the output is set to nil (if the output type supports nil values).
// By default, nil input values return a CodeNull error.
func (v *IntRuleSet[T]) WithNil() *IntRuleSet[T] <span class="cov2" title="2">{
        return &amp;IntRuleSet[T]{
                strict:   v.strict,
                parent:   v,
                base:     v.base,
                required: v.required,
                withNil:  true,
                rounding: v.rounding,
                label:    "WithNil()",
        }
}</span>

// Apply performs validation of a RuleSet against a value and assigns the result to the output parameter.
// Apply returns a ValidationErrorCollection if any validation errors occur.
func (ruleSet *IntRuleSet[T]) Apply(ctx context.Context, input any, output any) errors.ValidationErrorCollection <span class="cov9" title="277">{
        // Check if withNil is enabled and input is nil
        if handled, err := util.TrySetNilIfAllowed(ctx, ruleSet.withNil, input, output); handled </span><span class="cov2" title="3">{
                return err
        }</span>

        // Ensure output is a non-nil pointer
        <span class="cov9" title="274">outputVal := reflect.ValueOf(output)
        if outputVal.Kind() != reflect.Ptr || outputVal.IsNil() </span><span class="cov2" title="3">{
                return errors.Collection(errors.Errorf(
                        errors.CodeInternal, ctx, "Output must be a non-nil pointer",
                ))
        }</span>

        // Attempt to coerce the input value to an integer
        <span class="cov9" title="271">intval, validationErr := ruleSet.coerceInt(input, ctx)
        if validationErr != nil </span><span class="cov6" title="36">{
                return errors.Collection(validationErr)
        }</span>

        // Handle setting the value in output
        <span class="cov9" title="235">outputElem := outputVal.Elem()

        var assignable bool

        // Format the integer as a string using the same base as input parsing
        strVal := formatInt(intval, ruleSet.base)

        // Check if output is a string type
        if outputElem.Kind() == reflect.String </span><span class="cov5" title="17">{
                outputElem.SetString(strVal)
                assignable = true
        }</span> else<span class="cov9" title="218"> if outputElem.Kind() == reflect.Ptr &amp;&amp; outputElem.Type().Elem().Kind() == reflect.String </span><span class="cov3" title="6">{
                // Handle pointer to string
                if outputElem.IsNil() </span><span class="cov2" title="3">{
                        newStrPtr := reflect.New(outputElem.Type().Elem())
                        newStrPtr.Elem().SetString(strVal)
                        outputElem.Set(newStrPtr)
                }</span> else<span class="cov2" title="3"> {
                        outputElem.Elem().SetString(strVal)
                }</span>
                <span class="cov3" title="6">assignable = true</span>
        } else<span class="cov9" title="212"> if (outputElem.Kind() == reflect.Interface &amp;&amp; outputElem.IsNil()) ||
                (outputElem.Kind() == reflect.Int || outputElem.Kind() == reflect.Int8 ||
                        outputElem.Kind() == reflect.Int16 || outputElem.Kind() == reflect.Int32 ||
                        outputElem.Kind() == reflect.Int64 || outputElem.Type().AssignableTo(reflect.TypeOf(intval))) </span><span class="cov9" title="211">{

                // If output is a nil interface, or an assignable type, set it directly to the new integer value
                outputElem.Set(reflect.ValueOf(intval))
                assignable = true
        }</span>

        // If the types are incompatible, return an error
        <span class="cov9" title="235">if !assignable </span><span class="cov1" title="1">{
                return errors.Collection(errors.Errorf(
                        errors.CodeInternal, ctx, "Cannot assign %T to %T", intval, outputElem.Interface(),
                ))
        }</span>

        <span class="cov9" title="234">allErrors := errors.Collection()

        for currentRuleSet := ruleSet; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov10" title="384">{
                if currentRuleSet.rule != nil </span><span class="cov7" title="98">{
                        if err := currentRuleSet.rule.Evaluate(ctx, intval); err != nil </span><span class="cov6" title="33">{
                                allErrors = append(allErrors, err...)
                        }</span>
                }
        }

        <span class="cov9" title="234">if len(allErrors) != 0 </span><span class="cov6" title="33">{
                return allErrors
        }</span>
        <span class="cov9" title="201">return nil</span>
}

// Evaluate performs validation of a RuleSet against an integer value and returns a ValidationErrorCollection.
func (v *IntRuleSet[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov2" title="2">{
        allErrors := errors.Collection()

        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov3" title="4">{
                if currentRuleSet.rule != nil </span><span class="cov2" title="2">{
                        if err := currentRuleSet.rule.Evaluate(ctx, value); err != nil </span><span class="cov1" title="1">{
                                allErrors = append(allErrors, err...)
                        }</span>
                }
        }

        <span class="cov2" title="2">if len(allErrors) != 0 </span><span class="cov1" title="1">{
                return allErrors
        }</span> else<span class="cov1" title="1"> {
                return nil
        }</span>
}

// withoutConflicts returns the new array rule set with all conflicting rules removed.
// Does not mutate the existing rule sets.
func (ruleSet *IntRuleSet[T]) withoutConflicts(rule Rule[T]) *IntRuleSet[T] <span class="cov7" title="80">{
        if ruleSet.rule != nil </span><span class="cov5" title="22">{

                // Conflicting rules, skip this and return the parent
                if rule.Conflict(ruleSet.rule) </span><span class="cov4" title="11">{
                        return ruleSet.parent.withoutConflicts(rule)
                }</span>

        }

        <span class="cov7" title="69">if ruleSet.parent == nil </span><span class="cov7" title="58">{
                return ruleSet
        }</span>

        <span class="cov4" title="11">newParent := ruleSet.parent.withoutConflicts(rule)

        if newParent == ruleSet.parent </span><span class="cov3" title="6">{
                return ruleSet
        }</span>

        <span class="cov3" title="5">return &amp;IntRuleSet[T]{
                strict:   ruleSet.strict,
                base:     ruleSet.base,
                rule:     ruleSet.rule,
                required: ruleSet.required,
                withNil:  ruleSet.withNil,
                parent:   newParent,
                rounding: ruleSet.rounding,
                label:    ruleSet.label,
        }</span>
}

// WithRule returns a new child rule set that applies a custom validation rule.
// The custom rule is evaluated during validation and any errors it returns are included in the validation result.
func (ruleSet *IntRuleSet[T]) WithRule(rule Rule[T]) *IntRuleSet[T] <span class="cov7" title="58">{
        return &amp;IntRuleSet[T]{
                strict:   ruleSet.strict,
                rule:     rule,
                parent:   ruleSet.withoutConflicts(rule),
                base:     ruleSet.base,
                required: ruleSet.required,
                withNil:  ruleSet.withNil,
                rounding: ruleSet.rounding,
        }
}</span>

// WithRuleFunc returns a new child rule set that applies a custom validation function.
// The custom function is evaluated during validation and any errors it returns are included in the validation result.
func (v *IntRuleSet[T]) WithRuleFunc(rule RuleFunc[T]) *IntRuleSet[T] <span class="cov3" title="7">{
        return v.WithRule(rule)
}</span>

// Any returns a new RuleSet that wraps the number RuleSet in an Any rule set
// which can then be used in nested validation.
func (v *IntRuleSet[T]) Any() RuleSet[any] <span class="cov8" title="110">{
        return WrapAny[T](v)
}</span>

// typeName returns the name for the target integer type.
// Used for error message formatting.
func (v *IntRuleSet[T]) typeName() string <span class="cov6" title="36">{
        return reflect.ValueOf(*new(T)).Kind().String()
}</span>

// String returns a string representation of the rule set suitable for debugging.
func (ruleSet *IntRuleSet[T]) String() string <span class="cov7" title="61">{
        label := ruleSet.label

        if label == "" &amp;&amp; ruleSet.rule != nil </span><span class="cov6" title="31">{
                label = ruleSet.rule.String()
        }</span>

        <span class="cov7" title="61">if ruleSet.parent != nil </span><span class="cov6" title="35">{
                return ruleSet.parent.String() + "." + label
        }</span>
        <span class="cov5" title="26">return label</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package rules

import (
        "context"
        "reflect"

        "proto.zip/studio/validate/pkg/errors"
        "proto.zip/studio/validate/pkg/rulecontext"
)

type knownKeyType byte

const (
        knownConstKey knownKeyType = iota
        knownDynamicKey
)

// knownKeys is a utility structure to track which keys are seen during validation.
type knownKeys[TK comparable] struct {
        keys map[TK]knownKeyType
}

// newKnownKeys creates a new instance of knownKeys.
func newKnownKeys[TK comparable](track bool) *knownKeys[TK] <span class="cov9" title="91">{
        if track </span><span class="cov8" title="61">{
                return &amp;knownKeys[TK]{keys: make(map[TK]knownKeyType)}
        }</span>
        <span class="cov7" title="30">return &amp;knownKeys[TK]{}</span>
}

// Add registers a known key.
func (k *knownKeys[TK]) Add(key TK) <span class="cov10" title="136">{
        if k.keys != nil </span><span class="cov9" title="93">{
                k.keys[key] = knownConstKey
        }</span>
}

// exists checks if a given key is known.
func (k *knownKeys[TK]) exists(key TK) bool <span class="cov9" title="113">{
        _, ok := k.keys[key]
        return ok
}</span>

// Check validates if all keys in the provided reflect.Value are known.
// It returns a ValidationErrorCollection with errors for each unexpected key.
//
// If allowUnknown is true when creating the object then this always returns an
// empty error collection.
func (k *knownKeys[TK]) Check(ctx context.Context, inValue reflect.Value) errors.ValidationErrorCollection <span class="cov8" title="78">{
        errs := errors.Collection()

        // If the knownKeys map is not initialized, return an empty error collection.
        if k.keys == nil </span><span class="cov6" title="26">{
                return errs
        }</span>

        <span class="cov8" title="52">unk := k.Unknown(inValue)
        for _, key := range unk </span><span class="cov6" title="16">{
                subContext := rulecontext.WithPathString(ctx, toPath(key))
                errs = append(errs, errors.Errorf(errors.CodeUnexpected, subContext, "unexpected field"))
        }</span>
        <span class="cov8" title="52">return errs</span>
}

// Unknown returns all the unexpected keys.
func (k *knownKeys[TK]) Unknown(inValue reflect.Value) []TK <span class="cov8" title="70">{
        var out []TK

        // Loop through each key in the input value and check if it's a known key.
        for _, key := range inValue.MapKeys() </span><span class="cov9" title="113">{
                keyVal := key.Interface().(TK)
                if !k.exists(keyVal) </span><span class="cov7" title="39">{
                        out = append(out, keyVal)
                }</span>
        }

        <span class="cov8" title="70">return out</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package rules

import (
        "context"
        "math"
        "reflect"
        "strconv"
        "strings"

        "proto.zip/studio/validate/pkg/errors"
)

// Tolerance for floating point to int conversions
const tolerance = 1e-9

// tryCoerceIntToInt attempts to coerce an int from one type to another and checks that no data was lost in the process.
func tryCoerceIntToInt[From, To integer](ruleSet *IntRuleSet[To], value From, ctx context.Context) (To, errors.ValidationError) <span class="cov5" title="27">{
        intval := To(value)
        if From(intval) != value </span><span class="cov4" title="9">{
                return 0, errors.NewRangeError(ctx, ruleSet.typeName())
        }</span>
        <span class="cov5" title="18">return intval, nil</span>
}

// tryCoerceFloatToInt attempts to coerce a float into an int and checks that no data was lost in the process.
// Rounding rules are applied when appropriate.
func tryCoerceFloatToInt[From floating, To integer](ruleSet *IntRuleSet[To], value From, ctx context.Context) (To, errors.ValidationError) <span class="cov7" title="76">{
        var int64val int64
        float64val := float64(value)

        rounding := ruleSet.rounding

        switch rounding </span>{
        case RoundingDown:<span class="cov4" title="10">
                int64val = int64(math.Floor(float64val))</span>
        case RoundingUp:<span class="cov4" title="10">
                int64val = int64(math.Ceil(float64val))</span>
        case RoundingHalfUp:<span class="cov4" title="14">
                int64val = int64(math.Round(float64val))</span>
        case RoundingHalfEven:<span class="cov5" title="18">
                int64val = int64(math.RoundToEven(float64val))</span>
        default:<span class="cov5" title="24">
                int64val = int64(math.Round(float64val))

                if math.Abs(float64(int64val)-float64val) &gt; tolerance </span><span class="cov2" title="3">{
                        return 0, errors.NewCoercionError(ctx, ruleSet.typeName(), reflect.ValueOf(value).Kind().String())
                }</span>
        }

        <span class="cov7" title="73">intval := To(int64val)

        if int64(intval) != int64val </span><span class="cov4" title="14">{
                return 0, errors.NewRangeError(ctx, ruleSet.typeName())
        }</span>

        <span class="cov7" title="59">return intval, nil</span>
}

// parseInt attempts to parse an int from a string while using reflection to get the right type.
func parseInt[To integer](value string, base int) (To, error) <span class="cov5" title="17">{
        t := reflect.TypeOf(*new(To))

        switch t.Kind() </span>{
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov2" title="2">
                intval, err := strconv.ParseUint(value, base, t.Bits())
                return To(intval), err</span>
        default:<span class="cov5" title="15">
                intval, err := strconv.ParseInt(value, base, t.Bits())
                return To(intval), err</span>
        }
}

// formatInt formats an integer to a string using the specified base.
func formatInt[T integer](value T, base int) string <span class="cov9" title="235">{
        t := reflect.TypeOf(value)

        switch t.Kind() </span>{
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov4" title="11">
                return strconv.FormatUint(uint64(value), base)</span>
        default:<span class="cov9" title="224">
                return strconv.FormatInt(int64(value), base)</span>
        }
}

// formatFloat formats a float to a string.
// If outputPrecision is set (&gt;= 0) via WithFixedOutput, uses fixed-point format with zero-padding.
// If rounding was applied via WithRounding, caps output precision at the rounding precision (no zero-padding).
// Otherwise, uses a smart format that avoids floating point artifacts.
func formatFloat[T floating](ruleSet *FloatRuleSet[T], value T) string <span class="cov9" title="211">{
        float64val := float64(value)

        // Get the bit size for the float type
        bits := reflect.TypeOf(*new(T)).Bits()

        // Find output precision and rounding precision by traversing the ruleSet chain
        outputPrecision := -1   // -1 means not set
        roundingPrecision := -1 // -1 means no rounding applied

        for rs := ruleSet; rs != nil; rs = rs.parent </span><span class="cov10" title="383">{
                if outputPrecision &lt; 0 &amp;&amp; rs.outputPrecision &gt;= 0 </span><span class="cov5" title="23">{
                        outputPrecision = rs.outputPrecision
                }</span>
                <span class="cov10" title="383">if roundingPrecision &lt; 0 &amp;&amp; rs.rounding != RoundingNone </span><span class="cov7" title="101">{
                        roundingPrecision = rs.precision
                }</span>
        }

        // If output precision is explicitly set via WithFixedOutput, use fixed-point format
        <span class="cov9" title="211">if outputPrecision &gt;= 0 </span><span class="cov5" title="23">{
                return strconv.FormatFloat(float64val, 'f', outputPrecision, bits)
        }</span>

        // If rounding was applied, cap output at the rounding precision (no zero-padding)
        <span class="cov8" title="188">if roundingPrecision &gt;= 0 </span><span class="cov7" title="98">{
                formatted := strconv.FormatFloat(float64val, 'f', roundingPrecision, bits)
                return trimTrailingZeros(formatted)
        }</span>

        // Default case: use 'g' format which automatically chooses the best representation
        // and avoids floating point artifacts
        <span class="cov7" title="90">sigDigits := 15 // float64 has ~15-17 decimal digits of precision, use 15 to be safe
        if bits == 32 </span><span class="cov5" title="23">{
                sigDigits = 7 // float32 has ~7 decimal digits of precision
        }</span>

        <span class="cov7" title="90">return strconv.FormatFloat(float64val, 'g', sigDigits, bits)</span>
}

// trimTrailingZeros removes trailing zeros after the decimal point.
func trimTrailingZeros(s string) string <span class="cov7" title="98">{
        dotIdx := strings.Index(s, ".")
        if dotIdx == -1 </span><span class="cov6" title="46">{
                return s
        }</span>

        // Find last non-zero character
        <span class="cov6" title="52">lastNonZero := len(s) - 1
        for lastNonZero &gt; dotIdx &amp;&amp; s[lastNonZero] == '0' </span><span class="cov3" title="4">{
                lastNonZero--
        }</span>

        // If we're at the decimal point, remove it too
        <span class="cov6" title="52">if lastNonZero == dotIdx </span><span class="cov1" title="1">{
                return s[:dotIdx]
        }</span>

        <span class="cov6" title="51">return s[:lastNonZero+1]</span>
}

// tryCoerceIntDefault attempts to convert to an int from a non-float and non-int type
func tryCoerceIntDefault[To integer](ruleSet *IntRuleSet[To], value any, ctx context.Context) (To, errors.ValidationError) <span class="cov5" title="20">{
        if ruleSet.strict </span><span class="cov1" title="1">{
                return 0, errors.NewCoercionError(ctx, ruleSet.typeName(), reflect.ValueOf(value).Kind().String())
        }</span>

        <span class="cov5" title="19">if str, ok := value.(string); ok </span><span class="cov5" title="17">{
                var err error

                intval, err := parseInt[To](str, ruleSet.base)
                if err != nil </span><span class="cov3" title="7">{
                        if err.(*strconv.NumError).Err == strconv.ErrRange </span><span class="cov2" title="3">{
                                return 0, errors.NewRangeError(ctx, ruleSet.typeName())
                        }</span>

                        <span class="cov3" title="4">return 0, errors.NewCoercionError(ctx, ruleSet.typeName(), "string")</span>
                }
                <span class="cov4" title="10">return To(intval), nil</span>
        }

        <span class="cov2" title="2">return 0, errors.NewCoercionError(ctx, ruleSet.typeName(), reflect.ValueOf(value).Kind().String())</span>
}

// coerceInt arrempts to convert the value to the appropriate number type and returns a validation error collection if it can't.
func (ruleSet *IntRuleSet[T]) coerceInt(value any, ctx context.Context) (T, errors.ValidationError) <span class="cov9" title="271">{
        switch x := value.(type) </span>{
        case T:<span class="cov8" title="148">
                return x, nil</span>
        case int:<span class="cov1" title="1">
                return tryCoerceIntToInt[int, T](ruleSet, x, ctx)</span>
        case int8:<span class="cov1" title="1">
                return tryCoerceIntToInt[int8, T](ruleSet, x, ctx)</span>
        case int16:<span class="cov3" title="5">
                return tryCoerceIntToInt[int16, T](ruleSet, x, ctx)</span>
        case int32:<span class="cov3" title="5">
                return tryCoerceIntToInt[int32, T](ruleSet, x, ctx)</span>
        case int64:<span class="cov3" title="5">
                return tryCoerceIntToInt[int64, T](ruleSet, x, ctx)</span>
        case uint:<span class="cov2" title="2">
                return tryCoerceIntToInt[uint, T](ruleSet, x, ctx)</span>
        case uint8:<span class="cov2" title="2">
                return tryCoerceIntToInt[uint8, T](ruleSet, x, ctx)</span>
        case uint16:<span class="cov2" title="2">
                return tryCoerceIntToInt[uint16, T](ruleSet, x, ctx)</span>
        case uint32:<span class="cov2" title="2">
                return tryCoerceIntToInt[uint32, T](ruleSet, x, ctx)</span>
        case uint64:<span class="cov2" title="2">
                return tryCoerceIntToInt[uint64, T](ruleSet, x, ctx)</span>
        case float32:<span class="cov6" title="39">
                return tryCoerceFloatToInt[float32, T](ruleSet, x, ctx)</span>
        case float64:<span class="cov6" title="37">
                return tryCoerceFloatToInt[float64, T](ruleSet, x, ctx)</span>
        default:<span class="cov5" title="20">
                return tryCoerceIntDefault[T](ruleSet, value, ctx)</span>
        }
}

// tryCoerceFloatToFloat attempts to coerce a float from one type to another and checks that no data was lost in the process.
func tryCoerceFloatToFloat[From, To floating](value From, ctx context.Context) (To, errors.ValidationError) <span class="cov6" title="50">{
        floatval := To(value)
        if From(floatval) != value </span><span class="cov2" title="2">{
                target := reflect.ValueOf(*new(To)).Kind().String()
                return 0, errors.NewRangeError(ctx, target)
        }</span>
        <span class="cov6" title="48">return floatval, nil</span>
}

// tryCoerceIntToFloat attempts to coerce an integer to a float type and checks that no data was lost.
// float32 can represent integers exactly up to 2^24 = 16777216
// float64 can represent integers exactly up to 2^53 = 9007199254740992
func tryCoerceIntToFloat[From integer, To floating](ruleSet *FloatRuleSet[To], value From, ctx context.Context) (To, errors.ValidationError) <span class="cov7" title="58">{
        floatval := To(value)

        // Determine the maximum exact integer value based on the target float type
        var maxExactFloat float64
        var zero To
        switch any(zero).(type) </span>{
        case float32:<span class="cov6" title="31">
                maxExactFloat = 1 &lt;&lt; 24</span> // 2^24
        case float64:<span class="cov5" title="27">
                maxExactFloat = 1 &lt;&lt; 53</span> // 2^53
        }

        // Check if the absolute value of the float exceeds the exact representation limit
        <span class="cov7" title="58">absFloatVal := math.Abs(float64(floatval))
        if absFloatVal &gt; maxExactFloat </span><span class="cov4" title="11">{
                return 0, errors.NewRangeError(ctx, ruleSet.typeName())
        }</span>

        // Also verify the round-trip conversion works correctly
        // This catches edge cases where the float is within range but still can't represent the exact integer
        <span class="cov6" title="47">if From(floatval) != value </span><span class="cov5" title="15">{
                return 0, errors.NewRangeError(ctx, ruleSet.typeName())
        }</span>

        <span class="cov6" title="32">return floatval, nil</span>
}

// tryCoerceFloatDefault attempts to convert to a floar from a non-float and non-int type
func tryCoerceFloatDefault[To floating](ruleSet *FloatRuleSet[To], value any, ctx context.Context) (To, errors.ValidationError) <span class="cov4" title="8">{
        if ruleSet.strict </span><span class="cov1" title="1">{
                return 0, errors.NewCoercionError(ctx, ruleSet.typeName(), reflect.ValueOf(value).Kind().String())
        }</span>

        <span class="cov3" title="7">if str, ok := value.(string); ok </span><span class="cov3" title="5">{
                var err error

                bits := reflect.TypeOf(*new(To)).Bits()
                floatval, err := strconv.ParseFloat(str, bits)

                if err != nil </span><span class="cov2" title="2">{
                        if err.(*strconv.NumError).Err == strconv.ErrRange </span><span class="cov1" title="1">{
                                return 0, errors.NewRangeError(ctx, ruleSet.typeName())
                        }</span>

                        <span class="cov1" title="1">return 0, errors.NewCoercionError(ctx, ruleSet.typeName(), "string")</span>
                }

                <span class="cov2" title="3">return To(floatval), nil</span>
        }

        <span class="cov2" title="2">return 0, errors.NewCoercionError(ctx, ruleSet.typeName(), reflect.ValueOf(value).Kind().String())</span>
}

// coerceInt arrempts to convert the value to the appropriate number type and returns a validation error collection if it can't.
func (v *FloatRuleSet[T]) coerceFloat(value any, ctx context.Context) (T, errors.ValidationError) <span class="cov9" title="244">{
        switch x := value.(type) </span>{
        case T:<span class="cov8" title="128">
                return x, nil</span>
        case int:<span class="cov2" title="2">
                return tryCoerceIntToFloat[int, T](v, x, ctx)</span>
        case int8:<span class="cov2" title="2">
                return tryCoerceIntToFloat[int8, T](v, x, ctx)</span>
        case int16:<span class="cov2" title="2">
                return tryCoerceIntToFloat[int16, T](v, x, ctx)</span>
        case int32:<span class="cov4" title="10">
                return tryCoerceIntToFloat[int32, T](v, x, ctx)</span>
        case int64:<span class="cov5" title="26">
                return tryCoerceIntToFloat[int64, T](v, x, ctx)</span>
        case uint:<span class="cov2" title="2">
                return tryCoerceIntToFloat[uint, T](v, x, ctx)</span>
        case uint8:<span class="cov2" title="2">
                return tryCoerceIntToFloat[uint8, T](v, x, ctx)</span>
        case uint16:<span class="cov2" title="2">
                return tryCoerceIntToFloat[uint16, T](v, x, ctx)</span>
        case uint32:<span class="cov2" title="3">
                return tryCoerceIntToFloat[uint32, T](v, x, ctx)</span>
        case uint64:<span class="cov3" title="7">
                return tryCoerceIntToFloat[uint64, T](v, x, ctx)</span>
        case float32:<span class="cov6" title="47">
                return tryCoerceFloatToFloat[float32, T](x, ctx)</span>
        case float64:<span class="cov2" title="3">
                return tryCoerceFloatToFloat[float64, T](x, ctx)</span>
        default:<span class="cov4" title="8">
                return tryCoerceFloatDefault[T](v, value, ctx)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for maximum
type maxRule[T integer | floating] struct {
        max T
        fmt string
}

// Evaluate takes a context and integer value and returns an error if it is not equal or higher than the specified value.
func (rule *maxRule[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov10" title="30">{
        if value &gt; rule.max </span><span class="cov6" title="7">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMax, ctx, "field cannot be greater than %d", rule.max),
                )
        }</span>

        <span class="cov9" title="23">return nil</span>
}

// Conflict returns true for any maximum or exclusive maximum rule.
func (rule *maxRule[T]) Conflict(x Rule[T]) bool <span class="cov6" title="8">{
        _, ok1 := x.(*maxRule[T])
        _, ok2 := x.(*maxExclusiveRule[T])
        return ok1 || ok2
}</span>

// String returns the string representation of the maximum rule.
// Example: WithMax(2)
func (rule *maxRule[T]) String() string <span class="cov7" title="11">{
        return fmt.Sprintf("WithMax(%"+rule.fmt+")", rule.max)
}</span>

// WithMax returns a new child RuleSet that is constrained to the provided maximum value.
func (v *IntRuleSet[T]) WithMax(max T) *IntRuleSet[T] <span class="cov7" title="10">{
        return v.WithRule(&amp;maxRule[T]{
                max,
                "d",
        })
}</span>

// WithMax returns a new child RuleSet that is constrained to the provided maximum value.
func (v *FloatRuleSet[T]) WithMax(max T) *FloatRuleSet[T] <span class="cov4" title="4">{
        return v.WithRule(&amp;maxRule[T]{
                max,
                "f",
        })
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for exclusive maximum
type maxExclusiveRule[T integer | floating] struct {
        max T
        fmt string
}

// Evaluate takes a context and value and returns an error if it is not less than the specified value (exclusive).
func (rule *maxExclusiveRule[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov10" title="28">{
        if value &gt;= rule.max </span><span class="cov7" title="12">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMax, ctx, "field must be less than %d", rule.max),
                )
        }</span>

        <span class="cov8" title="16">return nil</span>
}

// Conflict returns true for any maximum or exclusive maximum rule.
func (rule *maxExclusiveRule[T]) Conflict(x Rule[T]) bool <span class="cov6" title="7">{
        _, ok1 := x.(*maxRule[T])
        _, ok2 := x.(*maxExclusiveRule[T])
        return ok1 || ok2
}</span>

// String returns the string representation of the exclusive maximum rule.
// Example: WithMaxExclusive(2)
func (rule *maxExclusiveRule[T]) String() string <span class="cov6" title="9">{
        return fmt.Sprintf("WithMaxExclusive(%"+rule.fmt+")", rule.max)
}</span>

// WithMaxExclusive returns a new child RuleSet that is constrained to values less than the provided value (exclusive).
func (v *IntRuleSet[T]) WithMaxExclusive(max T) *IntRuleSet[T] <span class="cov5" title="6">{
        return v.WithRule(&amp;maxExclusiveRule[T]{
                max,
                "d",
        })
}</span>

// WithMaxExclusive returns a new child RuleSet that is constrained to values less than the provided value (exclusive).
func (v *FloatRuleSet[T]) WithMaxExclusive(max T) *FloatRuleSet[T] <span class="cov4" title="4">{
        return v.WithRule(&amp;maxExclusiveRule[T]{
                max,
                "f",
        })
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for minimum
type minRule[T integer | floating] struct {
        min T
        fmt string
}

// Evaluate takes a context and integer value and returns an error if it is not equal or greater than the specified value.
func (rule *minRule[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov10" title="42">{
        if value &lt; rule.min </span><span class="cov6" title="12">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMin, ctx, "field must be greater than %d", rule.min),
                )
        }</span>

        <span class="cov9" title="30">return nil</span>
}

// Conflict returns true for any minimum or exclusive minimum rule.
func (rule *minRule[T]) Conflict(x Rule[T]) bool <span class="cov5" title="7">{
        _, ok1 := x.(*minRule[T])
        _, ok2 := x.(*minExclusiveRule[T])
        return ok1 || ok2
}</span>

// String returns the string representation of the minimum rule.
// Example: WithMin(2)
func (rule *minRule[T]) String() string <span class="cov6" title="10">{
        return fmt.Sprintf("WithMin(%"+rule.fmt+")", rule.min)
}</span>

// WithMin returns a new child RuleSet that is constrained to the provided minimum value.
func (v *IntRuleSet[T]) WithMin(min T) *IntRuleSet[T] <span class="cov8" title="22">{
        return v.WithRule(&amp;minRule[T]{
                min,
                "d",
        })
}</span>

// WithMin returns a new child RuleSet that is constrained to the provided minimum value.
func (v *FloatRuleSet[T]) WithMin(min T) *FloatRuleSet[T] <span class="cov4" title="5">{
        return v.WithRule(&amp;minRule[T]{
                min,
                "f",
        })
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for exclusive minimum
type minExclusiveRule[T integer | floating] struct {
        min T
        fmt string
}

// Evaluate takes a context and value and returns an error if it is not greater than the specified value (exclusive).
func (rule *minExclusiveRule[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov10" title="28">{
        if value &lt;= rule.min </span><span class="cov7" title="12">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMin, ctx, "field must be greater than %d", rule.min),
                )
        }</span>

        <span class="cov8" title="16">return nil</span>
}

// Conflict returns true for any minimum or exclusive minimum rule.
func (rule *minExclusiveRule[T]) Conflict(x Rule[T]) bool <span class="cov6" title="7">{
        _, ok1 := x.(*minRule[T])
        _, ok2 := x.(*minExclusiveRule[T])
        return ok1 || ok2
}</span>

// String returns the string representation of the exclusive minimum rule.
// Example: WithMinExclusive(2)
func (rule *minExclusiveRule[T]) String() string <span class="cov6" title="9">{
        return fmt.Sprintf("WithMinExclusive(%"+rule.fmt+")", rule.min)
}</span>

// WithMinExclusive returns a new child RuleSet that is constrained to values greater than the provided value (exclusive).
func (v *IntRuleSet[T]) WithMinExclusive(min T) *IntRuleSet[T] <span class="cov5" title="6">{
        return v.WithRule(&amp;minExclusiveRule[T]{
                min,
                "d",
        })
}</span>

// WithMinExclusive returns a new child RuleSet that is constrained to values greater than the provided value (exclusive).
func (v *FloatRuleSet[T]) WithMinExclusive(min T) *FloatRuleSet[T] <span class="cov4" title="4">{
        return v.WithRule(&amp;minExclusiveRule[T]{
                min,
                "f",
        })
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package rules

import (
        "context"
        "slices"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for an allowed list of values.
type valuesRule[T integer | floating] struct {
        values []T
        allow  bool
}

// exists returns true if the value exists in the rule
func (rule *valuesRule[T]) exists(value T) bool <span class="cov8" title="12">{
        low, high := 0, len(rule.values)-1

        for low &lt;= high </span><span class="cov10" title="19">{
                mid := (low + high) / 2

                if rule.values[mid] == value </span><span class="cov7" title="8">{
                        return true
                }</span>

                <span class="cov8" title="11">if rule.values[mid] &lt; value </span><span class="cov7" title="9">{
                        low = mid + 1
                }</span> else<span class="cov3" title="2"> {
                        high = mid - 1
                }</span>
        }

        <span class="cov5" title="4">return false</span>
}

// Evaluate takes a context and string value and returns an error depending on whether the value is in a list
// of allowed or denied values.
func (rule *valuesRule[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov8" title="12">{
        exists := rule.exists(value)

        if rule.allow </span><span class="cov5" title="5">{
                if !exists </span><span class="cov1" title="1">{
                        return errors.Collection(
                                errors.Errorf(errors.CodeNotAllowed, ctx, "field value is not allowed"),
                        )
                }</span>
        } else<span class="cov6" title="7"> if exists </span><span class="cov5" title="4">{
                return errors.Collection(
                        errors.Errorf(errors.CodeForbidden, ctx, "field value is not allowed"),
                )
        }</span>

        <span class="cov6" title="7">return nil</span>
}

// Conflict returns two for allow rules and always returns false for deny rules.
func (rule *valuesRule[T]) Conflict(x Rule[T]) bool <span class="cov5" title="5">{
        if !rule.allow </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov5" title="4">if other, ok := x.(*valuesRule[T]); ok </span><span class="cov4" title="3">{
                return other.allow
        }</span>
        <span class="cov1" title="1">return false</span>
}

// String returns the string representation of the values rule.
// Example: WithAllowedValues("b", "b", "c")
func (rule *valuesRule[T]) String() string <span class="cov7" title="8">{
        if !rule.allow </span><span class="cov4" title="3">{
                return util.StringsToRuleOutput("WithRejectedValues", rule.values)

        }</span>
        <span class="cov5" title="5">return util.StringsToRuleOutput("WithAllowedValues", rule.values)</span>
}

// getValuesRule returns the previous defined values rule for the rule set that has the expected value for "allow".
// Returns nil if there is none.
func (ruleSet *IntRuleSet[T]) getValuesRule(allow bool) *valuesRule[T] <span class="cov5" title="5">{
        for currentRuleSet := ruleSet; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov6" title="6">{
                if currentRuleSet.rule == nil </span><span class="cov3" title="2">{
                        continue</span>
                }

                <span class="cov5" title="4">if valueRule, ok := currentRuleSet.rule.(*valuesRule[T]); ok &amp;&amp; valueRule.allow == allow </span><span class="cov4" title="3">{
                        return valueRule
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// WithAllowedValues returns a new child RuleSet that is checked against the provided list of allowed values.
//
// This method can be called more than once and the allowed values are cumulative.
// Allowed values must still pass all other rules.
func (ruleSet *IntRuleSet[T]) WithAllowedValues(value T, rest ...T) *IntRuleSet[T] <span class="cov5" title="5">{
        existing := ruleSet.getValuesRule(true)
        l := 1 + len(rest)

        if existing != nil </span><span class="cov4" title="3">{
                l += len(existing.values)
        }</span>

        <span class="cov5" title="5">values := make([]T, 0, l)
        values = append(values, value)
        values = append(values, rest...)

        // Get previous rule if there is one
        if existing != nil </span><span class="cov4" title="3">{
                values = append(values, existing.values...)
        }</span>

        <span class="cov5" title="5">slices.Sort(values)

        return ruleSet.WithRule(&amp;valuesRule[T]{
                values,
                true,
        })</span>
}

// WithRejectedValues returns a new child RuleSet that is checked against the provided list of values hat should be rejected.
// This method can be called more than once.
//
// Rejected values will always be rejected even if they are in the allowed values list.
func (ruleSet *IntRuleSet[T]) WithRejectedValues(value T, rest ...T) *IntRuleSet[T] <span class="cov3" title="2">{
        values := make([]T, 0, 1+len(rest))
        values = append(values, value)
        values = append(values, rest...)

        slices.Sort(values)

        return ruleSet.WithRule(&amp;valuesRule[T]{
                values,
                false,
        })
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package rules

import (
        "context"
        "encoding/json"
        "fmt"
        "reflect"
        "sync"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
        "proto.zip/studio/validate/pkg/rulecontext"
)

const annotation = "validate"

// Implementation of RuleSet for objects and maps.
type ObjectRuleSet[T any, TK comparable, TV any] struct {
        NoConflict[T]
        allowUnknown bool
        key          Rule[TK]
        rule         RuleSet[TV]
        objRule      Rule[T]
        mapping      TK
        outputType   reflect.Type
        ptr          bool
        required     bool
        withNil      bool
        parent       *ObjectRuleSet[T, TK, TV]
        label        string
        condition    Conditional[T, TK]
        refs         *refTracker[TK]
        bucket       TK
        json         bool
}

// Struct returns a RuleSet that can be used to validate a struct of an
// arbitrary type.
//
// Struct uses the "validate" annotation to map input values to different
// properties of the object. This is useful for converting unstructured maps
// created from JSON and converting to an object.
func Struct[T any]() *ObjectRuleSet[T, string, any] <span class="cov6" title="51">{
        var empty [0]T

        ruleSet := &amp;ObjectRuleSet[T, string, any]{
                outputType: reflect.TypeOf(empty).Elem(),
        }

        kind := ruleSet.outputType.Kind()

        ruleSet.ptr = kind == reflect.Pointer
        if ruleSet.ptr </span><span class="cov6" title="44">{
                ruleSet.outputType = ruleSet.outputType.Elem()
                kind = ruleSet.outputType.Kind()
                ruleSet.label = fmt.Sprintf("ObjectRuleSet[*%v]", ruleSet.outputType)
        }</span> else<span class="cov3" title="7"> {
                ruleSet.label = fmt.Sprintf("ObjectRuleSet[%v]", ruleSet.outputType)
        }</span>

        <span class="cov6" title="51">if kind != reflect.Struct &amp;&amp; kind != reflect.Map </span><span class="cov1" title="1">{
                panic(fmt.Errorf("invalid output type for object rule set: %v", kind))</span>
        }

        <span class="cov6" title="50">mapped := make(map[string]bool)

        for i := 0; i &lt; ruleSet.outputType.NumField(); i++ </span><span class="cov8" title="182">{
                field := ruleSet.outputType.Field(i)

                if !field.IsExported() </span><span class="cov6" title="38">{
                        continue</span>
                }

                <span class="cov7" title="144">tagValue, ok := field.Tag.Lookup(annotation)
                emptyTag := tagValue == ""

                // Ignore empty tags if they exist
                if ok &amp;&amp; emptyTag </span><span class="cov2" title="3">{
                        continue</span>
                }

                <span class="cov7" title="141">var key string
                if emptyTag </span><span class="cov7" title="131">{
                        key = field.Name

                        // Don't allow the property names name to override the tagged mapping
                        _, ok := mapped[key]
                        if ok </span><span class="cov2" title="3">{
                                continue</span>
                        }
                } else<span class="cov4" title="10"> {
                        key = tagValue
                }</span>

                <span class="cov7" title="138">ruleSet = &amp;ObjectRuleSet[T, string, any]{
                        parent:     ruleSet,
                        key:        Constant[string](key),
                        mapping:    field.Name,
                        outputType: ruleSet.outputType,
                        ptr:        ruleSet.ptr,
                }

                mapped[key] = true</span>
        }

        <span class="cov6" title="50">return ruleSet</span>
}

// StringMap returns a new RuleSet that can be used to validate maps with strings as the
// keys and the specified data type (which can be "any") as the values.
func StringMap[T any]() *ObjectRuleSet[map[string]T, string, T] <span class="cov5" title="35">{
        var empty map[string]T

        return &amp;ObjectRuleSet[map[string]T, string, T]{
                outputType: reflect.TypeOf(empty),
        }
}</span>

// NewObjectMap returns a new RuleSet that can be used to validate maps with strings as the
// keys and the specified data type (which can be "any") as the values.
func Map[TK comparable, TV any]() *ObjectRuleSet[map[TK]TV, TK, TV] <span class="cov1" title="1">{
        var empty map[TK]TV

        return &amp;ObjectRuleSet[map[TK]TV, TK, TV]{
                outputType: reflect.TypeOf(empty),
        }
}</span>

// withParent is a helper function to assist in cloning object RuleSets.
func (v *ObjectRuleSet[T, TK, TV]) withParent() *ObjectRuleSet[T, TK, TV] <span class="cov8" title="156">{
        return &amp;ObjectRuleSet[T, TK, TV]{
                allowUnknown: v.allowUnknown,
                required:     v.required,
                withNil:      v.withNil,
                outputType:   v.outputType,
                ptr:          v.ptr,
                parent:       v,
                refs:         v.refs,
                json:         v.json,
        }
}</span>

// WithUnknown returns a new RuleSet that allows unknown keys in maps and objects.
//
// By default, if the validator finds an unknown key on a map it will return an error.
// WithUnknown allows keys that aren't defined to be present in the map.
// This is useful for parsing arbitrary JSON where additional keys may be included.
func (v *ObjectRuleSet[T, TK, TV]) WithUnknown() *ObjectRuleSet[T, TK, TV] <span class="cov4" title="11">{
        if v.allowUnknown </span><span class="cov1" title="1">{
                return v
        }</span>

        <span class="cov4" title="10">newRuleSet := v.withParent()
        newRuleSet.allowUnknown = true
        newRuleSet.label = "WithUnknown()"
        return newRuleSet</span>
}

// fullMapping is a helper function that returns the full object field mappings as a map.
func (v *ObjectRuleSet[T, TK, TV]) fullMapping() map[TK]TK <span class="cov6" title="53">{
        mapping := make(map[TK]TK)
        empty := new(TK)

        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov8" title="291">{
                if currentRuleSet.key != nil &amp;&amp; currentRuleSet.mapping != *empty </span><span class="cov8" title="204">{
                        mapping[currentRuleSet.key.(*ConstantRuleSet[TK]).Value()] = currentRuleSet.mapping
                }</span>
        }
        <span class="cov6" title="53">return mapping</span>
}

// mappingFor is a helper function that returns the key mapping given a specific key.
func (v *ObjectRuleSet[T, TK, TV]) mappingFor(ctx context.Context, key TK) (TK, bool) <span class="cov6" title="56">{
        var empty TK

        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov7" title="118">{
                if currentRuleSet.key != nil &amp;&amp; currentRuleSet.key.Evaluate(ctx, key) == nil &amp;&amp; currentRuleSet.mapping != empty </span><span class="cov6" title="55">{
                        return currentRuleSet.mapping, true
                }</span>
        }
        <span class="cov1" title="1">return empty, false</span>
}

// WithKey returns a new RuleSet with a validation rule for the specified key.
//
// If more than one call is made with the same key then all will be evaluated. However, the order
// in which they are run is not guaranteed.
//
// Multiple rule sets may run in parallel but only one will run at a time for each key since rule sets
// can return a mutated value.
func (v *ObjectRuleSet[T, TK, TV]) WithKey(key TK, ruleSet RuleSet[TV]) *ObjectRuleSet[T, TK, TV] <span class="cov7" title="86">{
        return v.WithConditionalKey(key, nil, ruleSet)
}</span>

// WithDynamicKey returns a new RuleSet with a validation rule for any key that matches the key rule.
// WithDynamicKey runs dynamic rules even if they match a key that has an already defined rule. Mappings are not applied
// to dynamic keys.
//
// If more than one call is made with the same key or overlapping dynamic rules, then all will be evaluated.
// However, the order in which they are run is not guaranteed.
//
// Multiple rule sets may run in parallel but only one will run at a time for each key since rule sets
// can return a mutated value. This is true even for constant value keys and other dynamic rules if the
// patterns overlap.
//
// If a key matches the key rules of any unconditional dynamic rule it will no longer be considered an "unknown" key.
//
// With maps, the dynamic keys are directly set on the output map. For structs you must set a dynamic key
// bucket using WithDynamicBucket.
func (v *ObjectRuleSet[T, TK, TV]) WithDynamicKey(keyRule Rule[TK], ruleSet RuleSet[TV]) *ObjectRuleSet[T, TK, TV] <span class="cov2" title="4">{
        var empty TK

        return v.withKeyHelper(
                keyRule,
                empty,
                nil,
                ruleSet,
        )
}</span>

// WithDynamicBucket tells the Rule Set to put matching keys into specific buckets. A bucket is expected to be a
// map with the key type (string for structs targets or variable for map) and a value type that matches the expected
// value.
//
// To avoid runtime errors it is usually best to also add a validation rule for the key using WithDynamic key to
// ensure the value is the correct type.
//
// This method is designed for unknown and dynamic keys only. If you have any explicit rules for your key, it will not
// be put into the dynamic bucket.
//
// If a key matches the dynamic bucket key rules then it will no longer be considered "unknown" and will not trigger an
// unknown key error. You are encouraged to add additional validation rules for the values.
//
// If a key belongs to more than one bucket it will be included in all of them.
//
// For structs:
//
//        When WithDynamicBucket is called this function will panic if the bucket property does not exist on the struct or
//        bucket property is not a map.
//        The value of the property will be nil until at least one key matches.
//
// For maps:
//
//        Running the rule set will panic if the value type is not "any" since any other type of value will not allow the bucket
//        map to be created.
//        The value of the bucket key in the map will not exist unless at least one key matches.
func (v *ObjectRuleSet[T, TK, TV]) WithDynamicBucket(keyRule Rule[TK], bucket TK) *ObjectRuleSet[T, TK, TV] <span class="cov4" title="11">{
        return v.WithConditionalDynamicBucket(keyRule, nil, bucket)
}</span>

// WithConditionalDynamicBucket behaves like WithDynamicBucket except the value is not sorted into the bucket unless the
// condition is met.
//
// If the only dynamic rules are conditional, the key will be considered unknown if no conditions match.
func (v *ObjectRuleSet[T, TK, TV]) WithConditionalDynamicBucket(keyRule Rule[TK], condition Conditional[T, TK], bucket TK) *ObjectRuleSet[T, TK, TV] <span class="cov4" title="13">{
        newRuleSet := v.withParent()

        newRuleSet.key = keyRule
        newRuleSet.condition = condition
        newRuleSet.bucket = bucket

        return newRuleSet
}</span>

// Keys returns the keys names that have rule sets associated with them.
// This will not return keys that don't have rule sets (even if they do have a mapping).
//
// It also will not return keys that are referenced WithRule or WithRuleFund. To get around this
// you may want to consider moving your rule set to WithKey or putting a simple permissive validator
// inside WithKey.
//
// The results are not sorted. You should not depend on the order of the results.
func (v *ObjectRuleSet[T, TK, TV]) KeyRules() []Rule[TK] <span class="cov5" title="22">{
        // Don't return identical keys more than once
        mapping := make(map[Rule[TK]]bool)
        keys := make([]Rule[TK], 0)

        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov7" title="93">{
                if currentRuleSet.key != nil &amp;&amp; currentRuleSet.rule != nil </span><span class="cov5" title="22">{
                        if !mapping[currentRuleSet.key] </span><span class="cov5" title="21">{
                                mapping[currentRuleSet.key] = true
                                keys = append(keys, currentRuleSet.key)
                        }</span>
                }
        }

        <span class="cov5" title="22">return keys</span>
}

// WithConditionalKey returns a new Rule with a validation rule for the specified key.
//
// It takes as an argument a Rule that is used to evaluate the entire object or map. If it returns a nil error then
// the conditional key Rule will be evaluated.
//
// Errors returned from the conditional Rule are not considered validation failures and will not be returned from
// the Validate / Evaluate functions. Errors in the conditional are only used to determine if the Rule should be evaluated.
//
// Conditional rules will be run any time after all fields they depend on are evaluated. For example if the conditional
// rule set looks for keys X and Y then the conditional will not be evaluated until all the rules for both X and Y have
// also been evaluated. This includes conditional  So if X is also dependent on Z then Z will also need to be complete.
//
// If one or more of the fields has an error then the conditional rule will not be run.
//
// WithRule and WithRuleFunc are both evaluated after any keys or conditional keys. Because of this, it is not possible to
// have a conditional key that is dependent on data that is modified in those
//
// If nil is passed in as the conditional then this method behaves identical to WithKey.
//
// This method will panic immediately if a circular dependency is detected.
func (v *ObjectRuleSet[T, TK, TV]) WithConditionalKey(key TK, condition Conditional[T, TK], ruleSet RuleSet[TV]) *ObjectRuleSet[T, TK, TV] <span class="cov7" title="101">{
        var destKey TK

        // Only check mapping if output type is a struct (not a map)
        if v.outputType.Kind() != reflect.Map </span><span class="cov6" title="56">{
                var ok bool
                destKey, ok = v.mappingFor(context.Background(), key)
                if !ok </span><span class="cov1" title="1">{
                        panic(fmt.Errorf("missing mapping for key: %s", toPath(key)))</span>
                }

                // Struct targets always have string as the key
                <span class="cov6" title="55">destKeyStr := any(destKey).(string)

                field, ok := v.outputType.FieldByName(destKeyStr)
                if !ok </span><span class="cov1" title="1">{
                        // Should never get here since the only way to make mappings is in the New method.
                        // But better to be defensive.
                        panic(fmt.Errorf("missing destination mapping for field: %s", toPath(destKey)))</span>
                }
                <span class="cov6" title="54">if !field.IsExported() </span><span class="cov1" title="1">{
                        // Should also never get here since the only way to make mappings is in the New method
                        // and New ignores unexported fields.
                        panic(fmt.Errorf("field is not exported: %s", toPath(destKey)))</span>
                }
        }

        <span class="cov7" title="98">return v.withKeyHelper(
                Constant[TK](key),
                destKey,
                condition,
                ruleSet,
        )</span>
}

// withKeyHelper returns a new rule set with the appropriate keys, conditions, and mappings set.
func (v *ObjectRuleSet[T, TK, TV]) withKeyHelper(key Rule[TK], destKey TK, condition Conditional[T, TK], ruleSet RuleSet[TV]) *ObjectRuleSet[T, TK, TV] <span class="cov7" title="102">{
        newRuleSet := v.withParent()

        newRuleSet.mapping = destKey
        newRuleSet.key = key
        newRuleSet.rule = ruleSet
        newRuleSet.condition = condition

        if condition != nil </span><span class="cov4" title="15">{
                if newRuleSet.refs == nil </span><span class="cov4" title="9">{
                        newRuleSet.refs = newRefTracker[TK]()
                }</span> else<span class="cov3" title="6"> {
                        newRuleSet.refs = newRuleSet.refs.Clone()
                }</span>

                <span class="cov4" title="15">for _, dependsOn := range condition.KeyRules() </span><span class="cov4" title="13">{
                        if err := newRuleSet.refs.Add(newRuleSet.key, dependsOn); err != nil </span><span class="cov2" title="3">{
                                panic(err)</span>
                        }
                }
        }

        <span class="cov7" title="99">return newRuleSet</span>
}

// Deprecated: Key is deprecated and will be removed in v1.0.0. Use WithKey instead.
func (v *ObjectRuleSet[T, TK, TV]) Key(key TK, ruleSet RuleSet[TV]) *ObjectRuleSet[T, TK, TV] <span class="cov1" title="2">{
        return v.WithKey(key, ruleSet)
}</span>

// Required returns a boolean indicating if the value is allowed to be omitted when included in a nested object.
func (v *ObjectRuleSet[T, TK, TV]) Required() bool <span class="cov6" title="46">{
        return v.required
}</span>

// WithRequired returns a new child rule set that requires the value to be present when nested in an object.
// When a required field is missing from the input, validation fails with an error.
func (v *ObjectRuleSet[T, TK, TV]) WithRequired() *ObjectRuleSet[T, TK, TV] <span class="cov3" title="5">{
        if v.required </span><span class="cov1" title="1">{
                return v
        }</span>

        <span class="cov2" title="4">newRuleSet := v.withParent()
        newRuleSet.required = true
        newRuleSet.label = "WithRequired()"
        return newRuleSet</span>
}

// WithNil returns a new child rule set that allows nil input values.
// When nil input is provided, validation passes and the output is set to nil (if the output type supports nil values).
// By default, nil input values return a CodeNull error.
func (v *ObjectRuleSet[T, TK, TV]) WithNil() *ObjectRuleSet[T, TK, TV] <span class="cov1" title="2">{
        newRuleSet := v.withParent()
        newRuleSet.withNil = true
        newRuleSet.label = "WithNil()"
        return newRuleSet
}</span>

// contextErrorToValidation takes a context error and returns a validation error.
func contextErrorToValidation(ctx context.Context) errors.ValidationError <span class="cov4" title="15">{
        switch ctx.Err() </span>{
        case nil:<span class="cov1" title="1">
                return nil</span>
        case context.DeadlineExceeded:<span class="cov3" title="5">
                return errors.Errorf(errors.CodeTimeout, ctx, "validation timed out before completing")</span>
        case context.Canceled:<span class="cov3" title="8">
                return errors.Errorf(errors.CodeCancelled, ctx, "validation was cancelled")</span>
        default:<span class="cov1" title="1">
                return errors.Errorf(errors.CodeInternal, ctx, "unknown context error: %v", ctx.Err())</span>
        }
}

// wait blocks until either the context is cancelled or the wait group is done (all keys have been validated).
func wait(ctx context.Context, wg *sync.WaitGroup, errorsCh chan errors.ValidationErrorCollection, listenForCancelled bool) errors.ValidationErrorCollection <span class="cov8" title="182">{
        done := make(chan struct{})

        go func() </span><span class="cov8" title="182">{
                wg.Wait()
                close(done)
        }</span>()

        <span class="cov8" title="182">allErrors := errors.Collection()

        for </span><span class="cov10" title="646">{
                select </span>{
                case err := &lt;-errorsCh:<span class="cov5" title="22">
                        allErrors = append(allErrors, err...)</span>
                case &lt;-ctx.Done():<span class="cov9" title="446">
                        if listenForCancelled </span><span class="cov2" title="4">{
                                wg.Wait()
                                return append(allErrors, contextErrorToValidation(ctx))
                        }</span>
                case &lt;-done:<span class="cov8" title="178">
                        return allErrors</span>
                }
        }
}

// done checks if the context is done and returns a bool.
func done(ctx context.Context) bool <span class="cov8" title="220">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov3" title="5">
                return true</span>
        default:<span class="cov8" title="215">
                return false</span>
        }
}

// evaluateKeyRule evaluates a single key rule.
// Note that this function is meant to be called on the rule set that contains the rule.
func (ruleSet *ObjectRuleSet[T, TK, TV]) evaluateKeyRule(ctx context.Context, out *T, wg *sync.WaitGroup, outValueMutex *sync.Mutex, errorsCh chan errors.ValidationErrorCollection, key TK, inFieldValue reflect.Value, s setter[TK], counters *counterSet[TK], dynamicBuckets []*ObjectRuleSet[T, TK, TV]) <span class="cov7" title="118">{
        defer wg.Done()
        counters.Lock(key)
        defer counters.Unlock(key)

        // Don't keep evaluating if the context has been canceled.
        if done(ctx) </span><span class="cov1" title="1">{
                return
        }</span>

        // Exit early if the condition is not met.
        <span class="cov7" title="117">if ruleSet.condition != nil </span><span class="cov3" title="6">{
                keys := ruleSet.condition.KeyRules()
                counters.Wait(keys...)

                ok := func() bool </span><span class="cov3" title="6">{
                        outValueMutex.Lock()
                        defer outValueMutex.Unlock()
                        return ruleSet.condition.Evaluate(ctx, *out) == nil
                }</span>()

                <span class="cov3" title="6">if !ok </span><span class="cov2" title="3">{
                        return
                }</span>
        }

        <span class="cov7" title="114">if inFieldValue.Kind() == reflect.Invalid </span><span class="cov4" title="14">{
                if ruleSet.rule.Required() </span><span class="cov3" title="7">{
                        errorsCh &lt;- errors.Collection(
                                errors.Errorf(errors.CodeRequired, ctx, "field is required"),
                        )
                }</span>
                <span class="cov4" title="14">return</span>
        }

        <span class="cov7" title="100">var val TV
        errs := ruleSet.rule.Apply(ctx, inFieldValue.Interface(), &amp;val)
        if errs != nil </span><span class="cov4" title="13">{
                errorsCh &lt;- errs
                return
        }</span>

        <span class="cov7" title="87">outValueMutex.Lock()
        defer outValueMutex.Unlock()

        bucketMatched := false
        for _, bucketRuleSet := range dynamicBuckets </span><span class="cov1" title="1">{
                if bucketRuleSet.key.Evaluate(ctx, key) == nil &amp;&amp; (bucketRuleSet.condition == nil || bucketRuleSet.condition.Evaluate(ctx, *out) == nil) </span><span class="cov1" title="1">{
                        s.SetBucket(bucketRuleSet.bucket, key, val)
                        bucketMatched = true
                }</span>
        }

        <span class="cov7" title="87">if !bucketMatched </span><span class="cov7" title="86">{
                s.Set(key, val)
        }</span>
}

// keyValue is a helper function that returns the name of a key for use in mapping and conditions
func (v *ObjectRuleSet[T, TK, TV]) keyValue(key TK, currentRuleSet *ObjectRuleSet[T, TK, TV], inValue reflect.Value, fromMap, fromSame bool) reflect.Value <span class="cov8" title="167">{
        var inFieldValue reflect.Value

        if fromMap </span><span class="cov7" title="130">{
                inFieldValue = inValue.MapIndex(reflect.ValueOf(key))
        }</span> else<span class="cov6" title="37"> if fromSame </span><span class="cov5" title="35">{
                // From same always has string keys since only structs would get this far so we can cast it.
                keyStr := any(currentRuleSet.mapping).(string)
                inFieldValue = inValue.FieldByName(keyStr)
        }</span> else<span class="cov1" title="2"> {
                // We know this isn't a map so the only option for a key is a string
                keyStr := any(key).(string)
                inFieldValue = inValue.FieldByName(keyStr)
        }</span>

        <span class="cov8" title="167">return inFieldValue</span>
}

// evaluateKeyRules evaluates the rules for each key and called evaluateKeyRule.
func (v *ObjectRuleSet[T, TK, TV]) evaluateKeyRules(ctx context.Context, out *T, inValue reflect.Value, s setter[TK], fromMap, fromSame bool) errors.ValidationErrorCollection <span class="cov7" title="91">{
        allErrors := errors.Collection()
        var emptyKey TK

        // Tracks which keys are known so we can create errors for unknown keys.
        knownKeys := newKnownKeys[TK]((!v.allowUnknown || s.Map()) &amp;&amp; fromMap)

        // Add each key to the counter.
        // We need this because conditional keys cannot run until all rule sets are run since rule sets are able
        // to mutate values.
        // For dynamic keys we must increment for all matching keys.
        counters := newCounterSet[TK]()
        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov9" title="421">{
                if currentRuleSet.key != nil &amp;&amp; currentRuleSet.rule != nil </span><span class="cov7" title="116">{
                        if c, ok := currentRuleSet.key.(*ConstantRuleSet[TK]); ok </span><span class="cov7" title="112">{
                                counters.Increment(c.Value())
                        }</span> else<span class="cov2" title="4"> if fromMap </span><span class="cov2" title="4">{
                                // Dynamic keys only make sense if the source is a map.
                                for _, mapKeyValue := range inValue.MapKeys() </span><span class="cov3" title="7">{
                                        key, ok := mapKeyValue.Interface().(TK)

                                        if ok &amp;&amp; currentRuleSet.key.Evaluate(ctx, key) == nil </span><span class="cov3" title="6">{
                                                counters.Increment(key)
                                        }</span>
                                }
                        }
                }
        }

        // Handle concurrency for the rule evaluation
        <span class="cov7" title="91">errorsCh := make(chan errors.ValidationErrorCollection)
        defer close(errorsCh)
        var outValueMutex sync.Mutex

        // Pre caching a list of dynamic buckets lets us avoid extra loops.
        // This method is faster in all cases where there is at least one bucket and the input has dynamic values
        dynamicBuckets := make([]*ObjectRuleSet[T, TK, TV], 0)
        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov9" title="421">{
                if currentRuleSet.bucket != emptyKey </span><span class="cov5" title="26">{
                        dynamicBuckets = append(dynamicBuckets, currentRuleSet)
                }</span>
        }

        // Wait for all the rules to finish
        <span class="cov7" title="91">var wg sync.WaitGroup

        // Loop through all the rule sets and evaluate the rules
        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov9" title="421">{
                if currentRuleSet.rule == nil </span><span class="cov8" title="305">{
                        continue</span>
                }

                <span class="cov7" title="116">if c, ok := currentRuleSet.key.(*ConstantRuleSet[TK]); ok </span><span class="cov7" title="112">{
                        key := c.Value()
                        inFieldValue := v.keyValue(key, currentRuleSet, inValue, fromMap, fromSame)
                        knownKeys.Add(key)
                        subContext := rulecontext.WithPathString(ctx, toPath(key))
                        wg.Add(1)
                        go currentRuleSet.evaluateKeyRule(subContext, out, &amp;wg, &amp;outValueMutex, errorsCh, key, inFieldValue, s, counters, nil)

                }</span> else<span class="cov2" title="4"> if fromMap </span><span class="cov2" title="4">{
                        // Dynamic keys only make sense if the source is a map.
                        for _, mapKeyValue := range inValue.MapKeys() </span><span class="cov3" title="7">{
                                key, ok := mapKeyValue.Interface().(TK)

                                if ok &amp;&amp; currentRuleSet.key.Evaluate(ctx, key) == nil </span><span class="cov3" title="6">{
                                        inFieldValue := v.keyValue(key, currentRuleSet, inValue, fromMap, fromSame)
                                        subContext := rulecontext.WithPathString(ctx, toPath(key))
                                        knownKeys.Add(key)
                                        wg.Add(1)
                                        go currentRuleSet.evaluateKeyRule(subContext, out, &amp;wg, &amp;outValueMutex, errorsCh, key, inFieldValue, s, counters, dynamicBuckets)
                                }</span>
                        }
                }
        }

        // Unknown fields are not concurrent for now so we need to wait for all rule evaluations to finish
        <span class="cov7" title="91">ruleErrors := wait(ctx, &amp;wg, errorsCh, true)

        // Throw all applicable unknown keys into dynamic buckets.
        // Keys in dynamic buckets should not trigger an unknown key error.
        if len(dynamicBuckets) &gt; 0 </span><span class="cov4" title="9">{
                unk := knownKeys.Unknown(inValue)
                for _, key := range unk </span><span class="cov4" title="15">{
                        for _, bucketRuleSet := range dynamicBuckets </span><span class="cov6" title="49">{
                                inFieldValue := v.keyValue(key, bucketRuleSet, inValue, fromMap, fromSame)

                                if bucketRuleSet.key.Evaluate(ctx, key) == nil &amp;&amp; (bucketRuleSet.condition == nil || bucketRuleSet.condition.Evaluate(ctx, *out) == nil) </span><span class="cov5" title="18">{
                                        knownKeys.Add(key)
                                        s.SetBucket(bucketRuleSet.bucket, key, inFieldValue.Interface())
                                }</span>
                        }
                }
        }

        // Check for unknown values
        <span class="cov7" title="91">if !v.allowUnknown </span><span class="cov7" title="78">{
                // If allowUnknown is not set we want to error for each unknown value
                knownKeyErrors := knownKeys.Check(ctx, inValue)
                allErrors = append(allErrors, knownKeyErrors...)
        }</span> else<span class="cov4" title="13"> if fromMap &amp;&amp; s.Map() </span><span class="cov4" title="9">{
                // If allowUnknown is set and the output is a map we want to assign each key to the map output.
                for _, key := range knownKeys.Unknown(inValue) </span><span class="cov3" title="8">{
                        s.Set(key, inValue.MapIndex(reflect.ValueOf(key)).Interface())
                }</span>
        }

        <span class="cov7" title="91">return append(allErrors, ruleErrors...)</span>
}

// evaluateObjectRules evaluates the object
func (v *ObjectRuleSet[T, TK, TV]) evaluateObjectRules(ctx context.Context, out *T) errors.ValidationErrorCollection <span class="cov7" title="91">{
        var wg sync.WaitGroup
        var outValueMutex sync.Mutex
        errorsCh := make(chan errors.ValidationErrorCollection)
        defer close(errorsCh)

        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov9" title="414">{
                if currentRuleSet.objRule != nil </span><span class="cov3" title="6">{
                        if done(ctx) </span><span class="cov1" title="1">{
                                break</span>
                        }

                        <span class="cov3" title="5">wg.Add(1)
                        go func(objRule Rule[T]) </span><span class="cov3" title="5">{
                                outValueMutex.Lock()
                                defer outValueMutex.Unlock()
                                defer wg.Done()

                                if done(ctx) </span><span class="cov1" title="1">{
                                        return
                                }</span>

                                <span class="cov2" title="4">if err := objRule.Evaluate(ctx, *out); err != nil </span><span class="cov1" title="2">{
                                        errorsCh &lt;- err
                                }</span>

                        }(currentRuleSet.objRule)
                }
        }

        <span class="cov7" title="91">return wait(ctx, &amp;wg, errorsCh, !done(ctx))</span>
}

// newSetter creates a new setter for the rule set
func (ruleSet *ObjectRuleSet[T, TK, TV]) newSetter(outValue reflect.Value) setter[TK] <span class="cov7" title="99">{
        if ruleSet.outputType.Kind() == reflect.Map </span><span class="cov6" title="46">{
                return &amp;mapSetter[TK]{
                        out: outValue,
                }
        }</span>

        <span class="cov6" title="53">return &amp;structSetter[TK]{
                out:     outValue,
                mapping: ruleSet.fullMapping(),
        }</span>
}

// Apply performs validation of a RuleSet against a value and assigns the result to the output parameter.
// Apply returns a ValidationErrorCollection if any validation errors occur.
func (v *ObjectRuleSet[T, TK, TV]) Apply(ctx context.Context, value any, output any) errors.ValidationErrorCollection <span class="cov7" title="115">{
        // Check if withNil is enabled and value is nil
        if handled, err := util.TrySetNilIfAllowed(ctx, v.withNil, value, output); handled </span><span class="cov2" title="3">{
                return err
        }</span>

        // Ensure output is a non-nil pointer
        <span class="cov7" title="112">rv := reflect.ValueOf(output)
        if rv.Kind() != reflect.Ptr || rv.IsNil() </span><span class="cov4" title="10">{
                return errors.Collection(errors.Errorf(
                        errors.CodeInternal, ctx, "Output must be a non-nil pointer",
                ))
        }</span>

        // If this is true we need to assign the output at the end of the Apply since we can't assign it directly initially.
        <span class="cov7" title="102">assignLater := false

        var out *T

        // If output is the correct type, we use the pointer, otherwise we check if it can be assigned
        // so we can assign it later. We need an pointer to the correct output type regardless of the actual type of "output"
        // since the rules are strongly typed.

        elem := rv.Elem()

        if elem.Type() == v.outputType </span><span class="cov5" title="27">{
                // The output directly points to the type.
                // At this point we already know output is non-nil since we check earlier.
                if v.outputType.Kind() == reflect.Map &amp;&amp; elem.IsNil() </span><span class="cov5" title="20">{
                        elem.Set(reflect.MakeMap(v.outputType))
                        out = output.(*T)
                }</span> else<span class="cov3" title="7"> if v.ptr </span><span class="cov1" title="1">{
                        x := output.(T)
                        out = &amp;x
                }</span> else<span class="cov3" title="6"> {
                        out = output.(*T)
                }</span>

        } else<span class="cov7" title="75"> if elem.Type() == reflect.PointerTo(v.outputType) </span><span class="cov5" title="24">{
                // Output is a pointer to the correct type (more specifically a double pointer).
                // This can happen a lot with generics because you are often taking a reference to &amp;T and
                // T is already a pointer.
                // However, this can happen when T is not already a pointer as well by doing a double reference
                // on output so we need to handle both.

                if elem.IsNil() </span><span class="cov5" title="22">{
                        out = new(T)
                }</span> else<span class="cov1" title="2"> if v.ptr </span><span class="cov1" title="1">{
                        out = output.(*T)
                }</span> else<span class="cov1" title="1"> {
                        tmp := *output.(**T)
                        out = tmp
                }</span>

                <span class="cov5" title="24">if v.ptr </span><span class="cov5" title="22">{
                        indirectOutValue := reflect.Indirect(reflect.ValueOf(out))
                        if indirectOutValue.IsNil() </span><span class="cov5" title="21">{
                                // The pointer points to a pointer with a nil value so we need to initialize that too.
                                indirectOutValue.Set(reflect.New(v.outputType))
                                elem.Set(reflect.ValueOf(*out))
                        }</span>
                } else<span class="cov1" title="2"> {
                        elem.Set(reflect.ValueOf(out))
                }</span>

        } else<span class="cov6" title="51"> if elem.Kind() == reflect.Interface </span><span class="cov6" title="49">{
                // We're pointing to a nil interface{}
                // We can't set up the pointer now so we'll need to deal with it later
                if !reflect.ValueOf(out).Type().AssignableTo(elem.Type()) </span><span class="cov1" title="1">{
                        return errors.Collection(errors.Errorf(errors.CodeInternal, ctx, "Cannot assign %T to %T", out, output))
                }</span>

                <span class="cov6" title="48">assignLater = true
                out = new(T)

                outElem := reflect.ValueOf(out).Elem()
                if (outElem.Kind() == reflect.Pointer || outElem.Kind() == reflect.Map) &amp;&amp; outElem.IsNil() </span><span class="cov6" title="42">{
                        if v.outputType.Kind() == reflect.Map </span><span class="cov5" title="26">{
                                newMap := reflect.MakeMap(v.outputType)
                                elem.Set(newMap)
                                reflect.ValueOf(out).Elem().Set(newMap)
                        }</span> else<span class="cov4" title="16"> {
                                newElem := reflect.New(v.outputType)
                                elem.Set(newElem)
                                reflect.ValueOf(out).Elem().Set(newElem)
                        }</span>
                }

        } else<span class="cov1" title="2"> {
                return errors.Collection(errors.Errorf(errors.CodeInternal, ctx, "Cannot assign %T to %T", out, output))
        }</span>

        <span class="cov7" title="99">var outValue reflect.Value
        if v.ptr </span><span class="cov6" title="39">{
                outValue = reflect.Indirect(reflect.ValueOf(*out))
        }</span> else<span class="cov6" title="60"> {
                outValue = reflect.Indirect(reflect.ValueOf(out))
        }</span>

        <span class="cov7" title="99">s := v.newSetter(outValue)

        inValue := reflect.Indirect(reflect.ValueOf(value))
        inKind := inValue.Kind()

        // Convert strings to JSON if necessary
        if v.json </span><span class="cov5" title="33">{
                var result map[string]interface{}
                coerced := false
                attempted := false

                if inKind == reflect.String </span><span class="cov5" title="29">{
                        attempted = true
                        if err := json.Unmarshal([]byte(inValue.String()), &amp;result); err == nil </span><span class="cov5" title="28">{
                                coerced = true
                        }</span>
                } else<span class="cov2" title="4"> if inKind == reflect.Slice &amp;&amp; inValue.Type().Elem().Kind() == reflect.Uint8 </span><span class="cov2" title="3">{
                        attempted = true
                        if err := json.Unmarshal(inValue.Bytes(), &amp;result); err == nil </span><span class="cov2" title="3">{
                                coerced = true
                        }</span>
                }

                <span class="cov5" title="33">if !coerced &amp;&amp; attempted </span><span class="cov1" title="1">{
                        return errors.Collection(
                                errors.NewCoercionError(ctx, "object, map, or JSON string", inKind.String()),
                        )
                }</span>

                <span class="cov5" title="32">if attempted </span><span class="cov5" title="31">{
                        inValue = reflect.ValueOf(result)
                        inKind = inValue.Kind()
                }</span>
        }

        <span class="cov7" title="98">fromMap := inKind == reflect.Map
        fromSame := !fromMap &amp;&amp; inValue.Type() == v.outputType

        if !fromMap &amp;&amp; inKind != reflect.Struct </span><span class="cov3" title="7">{
                return errors.Collection(
                        errors.NewCoercionError(ctx, "object or map", inKind.String()),
                )
        }</span>

        <span class="cov7" title="91">allErrors := errors.Collection()

        // Evaluate key rules
        keyErrs := v.evaluateKeyRules(ctx, out, inValue, s, fromMap, fromSame)
        allErrors = append(allErrors, keyErrs...)

        // Evaluate object rules
        valErrs := v.evaluateObjectRules(ctx, out)
        allErrors = append(allErrors, valErrs...)

        if len(allErrors) &gt; 0 </span><span class="cov5" title="31">{
                return allErrors
        }</span>

        <span class="cov6" title="60">if assignLater </span><span class="cov5" title="28">{
                elem.Set(reflect.ValueOf(out).Elem())
        }</span>

        <span class="cov6" title="60">return nil</span>
}

// Evaluate performs validation of a RuleSet against a value of the object type and returns a ValidationErrorCollection.
func (ruleSet *ObjectRuleSet[T, TK, TV]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov4" title="13">{
        // Prepare a variable to hold the output after applying the rule set
        var output T

        // Apply the rule set to the value within the provided context
        errs := ruleSet.Apply(ctx, value, &amp;output)
        return errs
}</span>

// WithJson allows the input to be a JSON encoded string.
func (v *ObjectRuleSet[T, TK, TV]) WithJson() *ObjectRuleSet[T, TK, TV] <span class="cov4" title="16">{
        if v.json </span><span class="cov1" title="1">{
                return v
        }</span>

        <span class="cov4" title="15">newRuleSet := v.withParent()
        newRuleSet.json = true
        return newRuleSet</span>
}

// WithRule returns a new child rule set that applies a custom validation rule.
// The custom rule is evaluated during validation and any errors it returns are included in the validation result.
func (v *ObjectRuleSet[T, TK, TV]) WithRule(rule Rule[T]) *ObjectRuleSet[T, TK, TV] <span class="cov3" title="8">{
        newRuleSet := v.withParent()
        newRuleSet.objRule = rule
        return newRuleSet
}</span>

// WithRuleFunc returns a new child rule set that applies a custom validation function.
// The custom function is evaluated during validation and any errors it returns are included in the validation result.
func (v *ObjectRuleSet[T, TK, TV]) WithRuleFunc(rule RuleFunc[T]) *ObjectRuleSet[T, TK, TV] <span class="cov3" title="8">{
        return v.WithRule(rule)
}</span>

// Any returns a new RuleSet that wraps the object RuleSet in an Any rule set
// which can then be used in nested validation.
func (v *ObjectRuleSet[T, TK, TV]) Any() RuleSet[any] <span class="cov6" title="41">{
        return WrapAny[T](v)
}</span>

// String returns a string representation of the rule set suitable for debugging.
func (ruleSet *ObjectRuleSet[T, TK, TV]) String() string <span class="cov6" title="43">{
        // Pass through mappings with no rules
        empty := new(TK)

        if ruleSet.mapping != *empty &amp;&amp; ruleSet.rule == nil </span><span class="cov5" title="24">{
                return ruleSet.parent.String()
        }</span>

        <span class="cov5" title="19">label := ruleSet.label

        if label == "" </span><span class="cov3" title="7">{
                if ruleSet.rule != nil </span><span class="cov3" title="5">{
                        if ruleSet.condition != nil </span><span class="cov1" title="1">{
                                label = fmt.Sprintf("WithConditionalKey(\"%s\", %s, %s)", toPath(ruleSet.key), ruleSet.condition, ruleSet.rule)
                        }</span> else<span class="cov2" title="4"> {
                                path := "&lt;dynamic&gt;"
                                if c, ok := ruleSet.key.(*ConstantRuleSet[TK]); ok </span><span class="cov2" title="4">{
                                        path = toQuotedPath(c.Value())
                                }</span>

                                <span class="cov2" title="4">label = fmt.Sprintf("WithKey(%s, %s)", path, ruleSet.rule)</span>
                        }
                } else<span class="cov1" title="2"> if ruleSet.objRule != nil </span><span class="cov1" title="1">{
                        label = ruleSet.objRule.String()
                }</span>
        }

        <span class="cov5" title="19">if ruleSet.parent != nil </span><span class="cov4" title="10">{
                return ruleSet.parent.String() + "." + label
        }</span>
        <span class="cov4" title="9">return label</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package rules

import (
        "fmt"
)

func toQuotedPath(key any) string <span class="cov3" title="4">{
        switch x := key.(type) </span>{
        case string:<span class="cov3" title="3">
                return `"` + x + `"`</span>
        }
        <span class="cov1" title="1">return fmt.Sprintf("%v", key)</span>
}

func toPath(key any) string <span class="cov10" title="138">{
        return fmt.Sprintf("%v", key)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package rules

import (
        "errors"
)

// refTracker[T] represents a structure to track references and their dependencies.
type refTracker[T comparable] struct {
        edges map[T][]T // edges represent the directed graph of dependencies.
}

// newRefTracker initializes and returns a new refTracker[T].
func newRefTracker[T comparable]() *refTracker[T] <span class="cov6" title="9">{
        return &amp;refTracker[T]{
                edges: make(map[T][]T),
        }
}</span>

// Add adds a new dependency between key and dependsOnKey.
// It returns an error if adding this dependency results in a circular reference.
func (rt *refTracker[T]) Add(keyRule, dependsOnKeyRule Rule[T]) error <span class="cov7" title="13">{

        // For now both key and depends on must be constants
        constKeyRule, keyIsConstant := keyRule.(*ConstantRuleSet[T])
        constDependsOnKeyRule, dependsOnKeyIsConstant := dependsOnKeyRule.(*ConstantRuleSet[T])

        if !keyIsConstant || !dependsOnKeyIsConstant </span><span class="cov1" title="1">{
                return errors.New("conditional rules do not support dynamic keys at this time")
        }</span>

        <span class="cov7" title="12">key := constKeyRule.Value()
        dependsOnKey := constDependsOnKeyRule.Value()

        // Initialize the key in the map if it doesn't exist.
        if _, exists := rt.edges[key]; !exists </span><span class="cov7" title="11">{
                rt.edges[key] = []T{}
        }</span>
        // Add the dependency.
        <span class="cov7" title="12">rt.edges[key] = append(rt.edges[key], dependsOnKey)

        // Check for circular references.
        visited := make(map[T]bool)
        stack := make(map[T]bool)

        if rt.hasCycle(key, visited, stack) </span><span class="cov2" title="2">{
                return errors.New("circular reference detected")
        }</span>
        <span class="cov7" title="10">return nil</span>
}

// hasCycle recursively checks for cycles in the graph using depth-first search.
// It returns true if a cycle is detected.
func (rt *refTracker[T]) hasCycle(node T, visited, stack map[T]bool) bool <span class="cov10" title="31">{
        // If the node is in the stack, it means we've encountered a cycle.
        if stack[node] </span><span class="cov2" title="2">{
                return true
        }</span>

        // If we've already visited the node, no need to revisit.
        <span class="cov9" title="29">if visited[node] </span><span class="cov1" title="1">{
                return false
        }</span>

        // Mark the node as visited and added to the stack.
        <span class="cov9" title="28">visited[node] = true
        stack[node] = true

        // Recursively check all dependencies of the current node.
        for _, child := range rt.edges[node] </span><span class="cov8" title="19">{
                if rt.hasCycle(child, visited, stack) </span><span class="cov5" title="5">{
                        return true
                }</span>
        }

        // Once we're done processing the current node, remove it from the stack.
        <span class="cov9" title="23">stack[node] = false
        return false</span>
}

func (rt *refTracker[T]) Clone() *refTracker[T] <span class="cov5" title="6">{
        clone := &amp;refTracker[T]{
                edges: make(map[T][]T),
        }

        for key, values := range rt.edges </span><span class="cov7" title="10">{
                clonedValues := make([]T, len(values))
                copy(clonedValues, values)
                clone.edges[key] = clonedValues
        }</span>

        <span class="cov5" title="6">return clone</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package rules

import "fmt"

// Rounding type is used to specify how a floating point number should be converted to
// a number with lower precision.
//
// These values are not guaranteed to be unchanged between versions. Don't use for serialization or cross-process communication.
type Rounding int

const (
        RoundingNone     Rounding = iota // Default. No rounding will be performed and return an error if the number is not already rounded.
        RoundingUp                       // Ceil. Always round up.
        RoundingDown                     // Floor. Always round down.
        RoundingHalfEven                 // "Bankers rounding." Round to the nearest even number.
        RoundingHalfUp                   // Always round half values up.
)

// String returns the string value for the rounding. Useful for debugging.
func (r Rounding) String() string <span class="cov10" title="37">{
        switch r </span>{
        case RoundingNone:<span class="cov1" title="1">
                return "None"</span>
        case RoundingUp:<span class="cov5" title="6">
                return "Up"</span>
        case RoundingDown:<span class="cov5" title="7">
                return "Down"</span>
        case RoundingHalfEven:<span class="cov7" title="16">
                return "HalfEven"</span>
        case RoundingHalfUp:<span class="cov5" title="6">
                return "HalfUp"</span>
        }
        <span class="cov1" title="1">return "Unknown"</span>
}

// WithRounding returns a new child RuleSet that applies the specified rounding method when converting floating point numbers to integers.
//
// Notes on floating point numbers:
// The RuleSet will attempt to convert floating point numbers to integers even if rounding is not enabled.
// If the number is not within tolerance (1e-9) of a whole number, an error will be returned.
func (v *IntRuleSet[T]) WithRounding(rounding Rounding) *IntRuleSet[T] <span class="cov6" title="9">{
        return &amp;IntRuleSet[T]{
                strict:   v.strict,
                parent:   v,
                base:     v.base,
                required: v.required,
                withNil:  v.withNil,
                rounding: rounding,
                label:    fmt.Sprintf("WithRounding(%s)", rounding.String()),
        }
}</span>

// WithRounding returns a new child RuleSet that applies the specified rounding method and precision to floating point numbers.
//
// Standard warnings for floating point numbers apply:
// - Some numbers cannot be represented precisely with floating points.
// - Sometimes the rounded result may have additional precision when the rounded number cannot be exactly represented.
// - For best results, consider using int for your math and data storage/transfer.
func (v *FloatRuleSet[T]) WithRounding(rounding Rounding, precision int) *FloatRuleSet[T] <span class="cov8" title="22">{
        return &amp;FloatRuleSet[T]{
                strict:          v.strict,
                parent:          v,
                required:        v.required,
                withNil:         v.withNil,
                rounding:        rounding,
                precision:       precision,
                outputPrecision: v.outputPrecision,
                label:           fmt.Sprintf("WithRounding(%s, %d)", rounding.String(), precision),
        }
}</span>

// WithFixedOutput returns a new child RuleSet that uses a fixed precision for string output.
// When outputting to a string type, the value will be zero-padded to exactly the specified number of decimal places.
// This is useful for consistent formatting where you always want the same number of decimal places.
//
// Example: WithFixedOutput(2) will format 123.4 as "123.40" and 123.456 as "123.46" (after rounding if applicable).
func (v *FloatRuleSet[T]) WithFixedOutput(precision int) *FloatRuleSet[T] <span class="cov8" title="23">{
        return &amp;FloatRuleSet[T]{
                strict:          v.strict,
                parent:          v,
                required:        v.required,
                withNil:         v.withNil,
                rounding:        v.rounding,
                precision:       v.precision,
                outputPrecision: precision,
                label:           fmt.Sprintf("WithFixedOutput(%d)", precision),
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package rules

import (
        "context"

        "proto.zip/studio/validate/pkg/errors"
)

// Rule defines the interface for validation rules.
// Rule implementations validate a value of type T and return any validation errors.
type Rule[T any] interface {
        // Evaluate takes in a context and value and returns any validation errors.
        Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection

        // Conflict returns true if two rules should not co-exist.
        // It may be used to remove duplicate rules when the new rule conflicts the existing rule.
        // The new rule should be kept and the old rule should be disabled.
        //
        // For example, if minimum is called a second time with a higher value, the new value should be taken.
        // If both rules are kept then the effective minimum is the smaller of the two.
        //
        // This method may return false if the previous rule should never be discarded.
        //
        // This method should be called even if the two rule types are not the same.
        Conflict(Rule[T]) bool

        // Returns the string representation of the rule for debugging.
        String() string
}

// RuleFunc implements the Rule interface for functions.
type RuleFunc[T any] func(ctx context.Context, value T) errors.ValidationErrorCollection

// Evaluate calls the rule function and returns the results.
func (rule RuleFunc[T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov10" title="32">{
        return rule(ctx, value)
}</span>

// Conflict always returns false for rule functions.
// Conflict cannot perform deduplication; implement the interface instead.
func (rule RuleFunc[T]) Conflict(_ Rule[T]) bool <span class="cov1" title="1">{
        return false
}</span>

// String returns "WithRuleFunc(...)" for function rules.
// String cannot be customized; implement the interface instead.
func (rule RuleFunc[T]) String() string <span class="cov4" title="4">{
        return "WithRuleFunc(...)"
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for maximum length
type maxLenRule[TV any, T lengthy[TV]] struct {
        max int
        msg string
}

// Evaluate takes a context and array/slice value and returns an error if it is not equal or lower in length than the specified value.
func (rule *maxLenRule[TV, T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov10" title="26">{
        if len(value) &gt; rule.max </span><span class="cov4" title="4">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMax, ctx, rule.msg, rule.max),
                )
        }</span>
        <span class="cov9" title="22">return nil</span>
}

// Conflict returns true for any maximum length rule.
func (rule *maxLenRule[TV, T]) Conflict(x Rule[T]) bool <span class="cov6" title="7">{
        _, ok := x.(*maxLenRule[TV, T])
        return ok
}</span>

// String returns the string representation of the maximum length rule.
// Example: WithMaxLen(2)
func (rule *maxLenRule[TV, T]) String() string <span class="cov7" title="10">{
        return fmt.Sprintf("WithMaxLen(%d)", rule.max)
}</span>

// WithMaxLen returns a new child RuleSet that is constrained to the provided maximum array/slice length.
func (v *SliceRuleSet[T]) WithMaxLen(max int) *SliceRuleSet[T] <span class="cov5" title="6">{
        return v.WithRule(&amp;maxLenRule[T, []T]{
                max,
                "list must be at most %d items long",
        })
}</span>

// WithMaxLen returns a new child RuleSet that is constrained to the provided maximum string length.
func (v *StringRuleSet) WithMaxLen(max int) *StringRuleSet <span class="cov5" title="5">{
        return v.WithRule(&amp;maxLenRule[any, string]{
                max,
                "value must be at most %d characters long",
        })
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for minimum length
type minLenRule[TV any, T lengthy[TV]] struct {
        min int
        msg string
}

// Evaluate takes a context and array/slice value and returns an error if it is not equal or lower in length than the specified value.
func (rule *minLenRule[TV, T]) Evaluate(ctx context.Context, value T) errors.ValidationErrorCollection <span class="cov10" title="40">{
        if len(value) &lt; rule.min </span><span class="cov7" title="15">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMin, ctx, rule.msg, rule.min),
                )
        }</span>
        <span class="cov8" title="25">return nil</span>
}

// Conflict returns true for any minimum length rule.
func (rule *minLenRule[TV, T]) Conflict(x Rule[T]) bool <span class="cov5" title="6">{
        _, ok := x.(*minLenRule[TV, T])
        return ok
}</span>

// String returns the string representation of the minimum length rule.
// Example: WithMinLen(2)
func (rule *minLenRule[TV, T]) String() string <span class="cov7" title="13">{
        return fmt.Sprintf("WithMinLen(%d)", rule.min)
}</span>

// WithMinLen returns a new child RuleSet that is constrained to the provided minimum array/slice length.
func (v *SliceRuleSet[T]) WithMinLen(min int) *SliceRuleSet[T] <span class="cov4" title="4">{
        return v.WithRule(&amp;minLenRule[T, []T]{
                min,
                "list must be at least %d items long",
        })
}</span>

// WithMinLen returns a new child RuleSet that is constrained to the provided minimum string length.
func (v *StringRuleSet) WithMinLen(min int) *StringRuleSet <span class="cov7" title="12">{
        return v.WithRule(&amp;minLenRule[any, string]{
                min,
                "value must be at least %d characters long",
        })
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package rules

import (
        "reflect"
)

// setter is responsible for assigning new values to the output.
// It abstracts the map vs struct logic making the RuleSet code cleaner and
// requiring less variables to be passed between validation function.
type setter[TK comparable] interface {
        Set(key TK, value any)
        SetBucket(bucketName, key TK, value any)
        Map() bool
}

// mapSetter is an implementation of the setter for
type mapSetter[TK comparable] struct {
        out reflect.Value
}

func (ms *mapSetter[TK]) Set(key TK, value any) <span class="cov9" title="44">{
        if value == nil </span><span class="cov2" title="2">{
                elemType := ms.out.Type().Elem()
                ms.out.SetMapIndex(reflect.ValueOf(key), reflect.Zero(elemType))
                return
        }</span>
        <span class="cov9" title="42">ms.out.SetMapIndex(reflect.ValueOf(key), reflect.ValueOf(value))</span>
}

func (ms *mapSetter[TK]) SetBucket(bucketName, key TK, value any) <span class="cov7" title="15">{
        // Check if the bucket already exists
        bucketValue := ms.out.MapIndex(reflect.ValueOf(bucketName))
        if !bucketValue.IsValid() </span><span class="cov6" title="11">{
                // If no bucket exists, create a new map[TK]interface{}
                newMap := make(map[TK]interface{})
                ms.out.SetMapIndex(reflect.ValueOf(bucketName), reflect.ValueOf(newMap))
                bucketValue = reflect.ValueOf(newMap)
        }</span> else<span class="cov4" title="4"> {
                bucketValue = bucketValue.Elem()
        }</span>

        // Set the key-value pair in the bucket
        <span class="cov7" title="15">if value == nil </span><span class="cov1" title="1">{
                elemType := bucketValue.Type().Elem()
                bucketValue.SetMapIndex(reflect.ValueOf(key), reflect.Zero(elemType))
        }</span> else<span class="cov6" title="14"> {
                bucketValue.SetMapIndex(reflect.ValueOf(key), reflect.ValueOf(value))
        }</span>
}

func (ms *mapSetter[TK]) Map() bool <span class="cov7" title="18">{
        return true
}</span>

type structSetter[TK comparable] struct {
        out     reflect.Value
        mapping map[TK]TK
}

func (ss *structSetter[TK]) Set(key TK, value any) <span class="cov10" title="55">{
        field := ss.out.FieldByName(any(ss.mapping[key]).(string))

        valueReflect := reflect.ValueOf(value)

        if value == nil </span><span class="cov1" title="1">{
                field.Set(reflect.Zero(field.Type()))
                return
        }</span>

        <span class="cov9" title="54">if field.Kind() == reflect.Ptr </span><span class="cov3" title="3">{
                if valueReflect.Kind() == reflect.Ptr </span><span class="cov1" title="1">{
                        field.Set(valueReflect)
                }</span> else<span class="cov2" title="2"> {
                        valPtr := reflect.New(field.Type().Elem())
                        valPtr.Elem().Set(valueReflect)
                        field.Set(valPtr)
                }</span>
        } else<span class="cov9" title="51"> {
                field.Set(valueReflect)
        }</span>
}

func (ss *structSetter[TK]) SetBucket(bucketName, key TK, value any) <span class="cov5" title="9">{
        // Get the field by bucket name
        field := ss.out.FieldByName(any(bucketName).(string))

        if !field.IsValid() || field.Kind() != reflect.Map </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov5" title="8">if field.IsNil() </span><span class="cov5" title="6">{
                // Initialize the map if it is nil
                mapType := field.Type()
                field.Set(reflect.MakeMap(mapType))
        }</span>

        // Set the key-value pair in the map
        <span class="cov5" title="8">keyValue := reflect.ValueOf(key)
        valueValue := reflect.ValueOf(value)
        if value == nil </span><span class="cov1" title="1">{
                valueValue = reflect.Zero(field.Type().Elem())
        }</span>
        <span class="cov5" title="8">field.SetMapIndex(keyValue, valueValue)</span>
}

func (ss *structSetter[TK]) Map() bool <span class="cov5" title="7">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package rules

import (
        "context"
        "fmt"
        "reflect"
        "strconv"
        "sync"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
        "proto.zip/studio/validate/pkg/rulecontext"
)

// Implementation of RuleSet for arrays of a given type.
type SliceRuleSet[T any] struct {
        NoConflict[[]T]
        itemRules RuleSet[T]
        rule      Rule[[]T]
        required  bool
        withNil   bool
        parent    *SliceRuleSet[T]
        label     string
}

// Slice creates a new slice RuleSet.
func Slice[T any]() *SliceRuleSet[T] <span class="cov7" title="58">{
        var empty [0]T

        return &amp;SliceRuleSet[T]{
                label: fmt.Sprintf("SliceRuleSet[%s]", reflect.TypeOf(empty).Elem().Kind()),
        }
}</span>

// Required returns a boolean indicating if the value is allowed to be omitted when included in a nested object.
func (v *SliceRuleSet[T]) Required() bool <span class="cov2" title="3">{
        return v.required
}</span>

// WithRequired returns a new child rule set that requires the value to be present when nested in an object.
// When a required field is missing from the input, validation fails with an error.
// WithRequired has no effect on slices if the RuleSet is strict since nil is not a valid slice.
func (v *SliceRuleSet[T]) WithRequired() *SliceRuleSet[T] <span class="cov2" title="3">{
        return &amp;SliceRuleSet[T]{
                parent:   v,
                required: true,
                withNil:  v.withNil,
                label:    "WithRequired()",
        }
}</span>

// WithNil returns a new child rule set that allows nil input values.
// When nil input is provided, validation passes and the output is set to nil (if the output type supports nil values).
// By default, nil input values return a CodeNull error.
func (v *SliceRuleSet[T]) WithNil() *SliceRuleSet[T] <span class="cov2" title="2">{
        return &amp;SliceRuleSet[T]{
                parent:   v,
                required: v.required,
                withNil:  true,
                label:    "WithNil()",
        }
}</span>

// WithItemRuleSet takes a new rule set to use to validate array items and returns a new child rule set.
//
// If this function is called more than once, only the most recent one will be used to validate the items.
// If you don't set an item rule set then the validator will attempt to cast the items to the correct type
// and perform no additional validation.
func (v *SliceRuleSet[T]) WithItemRuleSet(itemRules RuleSet[T]) *SliceRuleSet[T] <span class="cov5" title="14">{
        return &amp;SliceRuleSet[T]{
                itemRules: itemRules,
                parent:    v,
                required:  v.required,
                withNil:   v.withNil,
        }
}</span>

// getMaxLen extracts the maximum length from the rule set by traversing all rules.
// Returns -1 if no max length rule is found.
func (v *SliceRuleSet[T]) getMaxLen() int <span class="cov5" title="16">{
        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov5" title="20">{
                if currentRuleSet.rule != nil </span><span class="cov1" title="1">{
                        if maxRule, ok := currentRuleSet.rule.(*maxLenRule[T, []T]); ok </span><span class="cov1" title="1">{
                                return maxRule.max
                        }</span>
                }
        }
        <span class="cov5" title="15">return -1</span>
}

// sliceInputAdapter provides a unified interface for reading items from different input types.
type sliceInputAdapter interface {
        // next returns the next item, whether reading is complete, and any error.
        // Returns (item, done, error). If done is true, no more items are available.
        next(ctx context.Context) (reflect.Value, bool, errors.ValidationErrorCollection)
        // length returns the number of items if known, or -1 if unknown (e.g., for channels).
        length() int
}

// sliceOutputAdapter provides a unified interface for writing items to different output types.
type sliceOutputAdapter[T any] interface {
        // putIndex sets the value at the given index.
        putIndex(ctx context.Context, index int, value T) errors.ValidationErrorCollection
        // finalize completes the output operation (e.g., closing channels, assigning slices).
        finalize(ctx context.Context, length int) errors.ValidationErrorCollection
}

// sliceInputAdapterImpl implements sliceInputAdapter for slice and array inputs.
type sliceInputAdapterImpl struct {
        value reflect.Value
        index int
        len   int
}

func newSliceInputAdapter(value reflect.Value) sliceInputAdapter <span class="cov7" title="45">{
        return &amp;sliceInputAdapterImpl{
                value: value,
                index: 0,
                len:   value.Len(),
        }
}</span>

func (a *sliceInputAdapterImpl) next(ctx context.Context) (reflect.Value, bool, errors.ValidationErrorCollection) <span class="cov9" title="242">{
        if a.index &gt;= a.len </span><span class="cov6" title="41">{
                return reflect.Value{}, true, nil
        }</span>
        <span class="cov9" title="201">item := a.value.Index(a.index)
        a.index++
        return item, false, nil</span>
}

func (a *sliceInputAdapterImpl) length() int <span class="cov6" title="41">{
        return a.len
}</span>

// channelInputAdapter implements sliceInputAdapter for channel inputs.
type channelInputAdapter[T any] struct {
        recvChan &lt;-chan T
        maxLen   int
        count    int
}

func newChannelInputAdapter[T any](input any, maxLen int) (sliceInputAdapter, errors.ValidationErrorCollection) <span class="cov5" title="16">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.Collection(errors.Errorf(
                        errors.CodeInternal, context.Background(), "Input channel cannot be nil",
                ))
        }</span>

        // Use reflection to validate it's a channel and get the type
        <span class="cov5" title="16">inputVal := reflect.ValueOf(input)
        if inputVal.Kind() != reflect.Chan </span><span class="cov0" title="0">{
                return nil, errors.Collection(errors.Errorf(
                        errors.CodeInternal, context.Background(), "Input is not a channel",
                ))
        }</span>

        <span class="cov5" title="16">if inputVal.IsNil() </span><span class="cov1" title="1">{
                return nil, errors.Collection(errors.Errorf(
                        errors.CodeInternal, context.Background(), "Input channel cannot be nil",
                ))
        }</span>

        <span class="cov5" title="15">if inputVal.Type().ChanDir()&amp;reflect.RecvDir == 0 </span><span class="cov1" title="1">{
                return nil, errors.Collection(errors.Errorf(
                        errors.CodeInternal, context.Background(), "Input channel must be readable (recv)",
                ))
        }</span>

        // Try to convert to receive-only channel first, then bidirectional
        <span class="cov5" title="14">var recvChan &lt;-chan T
        switch ch := input.(type) </span>{
        case &lt;-chan T:<span class="cov1" title="1">
                recvChan = ch</span>
        case chan T:<span class="cov4" title="12">
                recvChan = ch</span>
        default:<span class="cov1" title="1">
                // Type assertion failed - channel element type doesn't match T
                expectedType := reflect.TypeOf((*T)(nil)).Elem()
                actualType := inputVal.Type().Elem()
                return nil, errors.Collection(errors.NewCoercionError(
                        context.Background(), expectedType.String(), actualType.String(),
                ))</span>
        }

        <span class="cov5" title="13">return &amp;channelInputAdapter[T]{
                recvChan: recvChan,
                maxLen:   maxLen,
                count:    0,
        }, nil</span>
}

func (a *channelInputAdapter[T]) next(ctx context.Context) (reflect.Value, bool, errors.ValidationErrorCollection) <span class="cov7" title="44">{
        // Check max length
        if a.maxLen &gt;= 0 &amp;&amp; a.count &gt;= a.maxLen </span><span class="cov1" title="1">{
                return reflect.Value{}, true, nil
        }</span>

        // Use regular select for channel receive with context cancellation
        <span class="cov6" title="43">select </span>{
        case &lt;-ctx.Done():<span class="cov2" title="3">
                return reflect.Value{}, true, errors.Collection(contextErrorToValidation(ctx))</span>
        case val, ok := &lt;-a.recvChan:<span class="cov6" title="40">
                if !ok </span><span class="cov4" title="9">{
                        // Channel closed
                        return reflect.Value{}, true, nil
                }</span>
                <span class="cov6" title="31">a.count++
                return reflect.ValueOf(val), false, nil</span>
        }
}

func (a *channelInputAdapter[T]) length() int <span class="cov5" title="13">{
        return -1 // Unknown length for channels
}</span>

// sliceOutputAdapterImpl implements sliceOutputAdapter for slice outputs.
type sliceOutputAdapterImpl[T any] struct {
        outputVal reflect.Value
        output    reflect.Value
        expected  reflect.Type
}

func newSliceOutputAdapter[T any](outputVal reflect.Value, expectedType reflect.Type) (sliceOutputAdapter[T], errors.ValidationErrorCollection) <span class="cov6" title="42">{
        // Start with empty slice, will grow as needed
        output := reflect.MakeSlice(reflect.SliceOf(expectedType), 0, 0)

        return &amp;sliceOutputAdapterImpl[T]{
                outputVal: outputVal,
                output:    output,
                expected:  expectedType,
        }, nil
}</span>

func (a *sliceOutputAdapterImpl[T]) putIndex(ctx context.Context, index int, value T) errors.ValidationErrorCollection <span class="cov9" title="197">{
        // Grow slice if needed
        if index &gt;= a.output.Len() </span><span class="cov9" title="197">{
                newLen := index + 1
                if newLen &gt; a.output.Cap() </span><span class="cov7" title="44">{
                        // Need to grow capacity
                        newCap := newLen * 2
                        if newCap &lt; 4 </span><span class="cov6" title="39">{
                                newCap = 4
                        }</span>
                        <span class="cov7" title="44">newSlice := reflect.MakeSlice(a.output.Type(), newLen, newCap)
                        // Copy existing elements
                        reflect.Copy(newSlice, a.output)
                        a.output = newSlice</span>
                } else<span class="cov9" title="153"> {
                        // Just extend length
                        a.output = a.output.Slice(0, newLen)
                }</span>
        }

        <span class="cov9" title="197">a.output.Index(index).Set(reflect.ValueOf(value))
        return nil</span>
}

func (a *sliceOutputAdapterImpl[T]) finalize(ctx context.Context, length int) errors.ValidationErrorCollection <span class="cov6" title="42">{
        // Resize to exact length if we know it
        if length &gt;= 0 </span><span class="cov6" title="42">{
                if length &gt; a.output.Len() </span><span class="cov1" title="1">{
                        // Need to grow to the specified length
                        if length &gt; a.output.Cap() </span><span class="cov1" title="1">{
                                newSlice := reflect.MakeSlice(a.output.Type(), length, length)
                                reflect.Copy(newSlice, a.output)
                                a.output = newSlice
                        }</span> else<span class="cov0" title="0"> {
                                a.output = a.output.Slice(0, length)
                        }</span>
                } else<span class="cov6" title="41"> if length &lt; a.output.Len() </span><span class="cov0" title="0">{
                        // Trim to specified length
                        a.output = a.output.Slice(0, length)
                }</span>
        }

        // Assign the result to the output
        <span class="cov6" title="42">outputElem := a.outputVal.Elem()
        if outputElem.Kind() == reflect.Interface &amp;&amp; outputElem.IsNil() </span><span class="cov2" title="3">{
                outputElem.Set(a.output)
        }</span> else<span class="cov6" title="39"> if a.output.Type().AssignableTo(outputElem.Type()) </span><span class="cov6" title="35">{
                outputElem.Set(a.output)
        }</span> else<span class="cov3" title="4"> {
                return errors.Collection(errors.Errorf(
                        errors.CodeInternal, ctx, "Cannot assign %T to %T", a.output.Interface(), outputElem.Interface(),
                ))
        }</span>
        <span class="cov6" title="38">return nil</span>
}

// channelOutputAdapter implements sliceOutputAdapter for channel outputs.
type channelOutputAdapter[T any] struct {
        sendChan chan&lt;- T
}

func newChannelOutputAdapter[T any](output any) (sliceOutputAdapter[T], errors.ValidationErrorCollection) <span class="cov5" title="16">{
        if output == nil </span><span class="cov0" title="0">{
                return nil, errors.Collection(errors.Errorf(
                        errors.CodeInternal, context.Background(), "Output channel cannot be nil",
                ))
        }</span>

        // Use reflection to validate it's a channel and get the type
        <span class="cov5" title="16">outputVal := reflect.ValueOf(output)
        if outputVal.Kind() != reflect.Chan </span><span class="cov0" title="0">{
                return nil, errors.Collection(errors.Errorf(
                        errors.CodeInternal, context.Background(), "Output is not a channel",
                ))
        }</span>

        <span class="cov5" title="16">if outputVal.IsNil() </span><span class="cov2" title="2">{
                return nil, errors.Collection(errors.Errorf(
                        errors.CodeInternal, context.Background(), "Output channel cannot be nil",
                ))
        }</span>

        <span class="cov5" title="14">if outputVal.Type().ChanDir()&amp;reflect.SendDir == 0 </span><span class="cov1" title="1">{
                return nil, errors.Collection(errors.Errorf(
                        errors.CodeInternal, context.Background(), "Output channel must be writable (send)",
                ))
        }</span>

        // Try to convert to send-only channel first, then bidirectional
        <span class="cov5" title="13">var sendChan chan&lt;- T
        switch ch := output.(type) </span>{
        case chan&lt;- T:<span class="cov0" title="0">
                sendChan = ch</span>
        case chan T:<span class="cov4" title="12">
                sendChan = ch</span>
        default:<span class="cov1" title="1">
                // Type assertion failed - channel element type doesn't match T
                expectedType := reflect.TypeOf((*T)(nil)).Elem()
                actualType := outputVal.Type().Elem()
                return nil, errors.Collection(errors.Errorf(
                        errors.CodeInternal, context.Background(), "Output channel element type %s is not compatible with %s",
                        actualType.String(), expectedType.String(),
                ))</span>
        }

        <span class="cov4" title="12">return &amp;channelOutputAdapter[T]{
                sendChan: sendChan,
        }, nil</span>
}

func (a *channelOutputAdapter[T]) putIndex(ctx context.Context, index int, value T) errors.ValidationErrorCollection <span class="cov6" title="25">{
        // Use regular select for channel send with context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov2" title="2">
                return errors.Collection(contextErrorToValidation(ctx))</span>
        case a.sendChan &lt;- value:<span class="cov5" title="23">
                return nil</span>
        }
}

func (a *channelOutputAdapter[T]) finalize(ctx context.Context, length int) errors.ValidationErrorCollection <span class="cov4" title="12">{
        close(a.sendChan)
        return nil
}</span>

// Apply performs validation of a RuleSet against a value and assigns the result to the output parameter.
// Apply returns a ValidationErrorCollection if any validation errors occur.
//
// Apply supports channels as both input and output. When using channels:
// - Input channel: reads values until closed, max length is hit, or context times out
// - Output channel: writes validated values in the same order as input
// - All errors are collected and returned at once
// - If validation is done concurrently, output is buffered to maintain order
func (v *SliceRuleSet[T]) Apply(ctx context.Context, input any, output any) errors.ValidationErrorCollection <span class="cov7" title="70">{
        // Check if withNil is enabled and input is nil
        if handled, err := util.TrySetNilIfAllowed(ctx, v.withNil, input, output); handled </span><span class="cov2" title="3">{
                return err
        }</span>

        // Ensure output is a non-nil pointer
        <span class="cov7" title="67">outputVal := reflect.ValueOf(output)
        if outputVal.Kind() != reflect.Ptr || outputVal.IsNil() </span><span class="cov3" title="4">{
                return errors.Collection(errors.Errorf(
                        errors.CodeInternal, ctx, "Output must be a non-nil pointer",
                ))
        }</span>

        <span class="cov7" title="63">valueOf := reflect.ValueOf(input)
        typeOf := valueOf.Type()
        kind := typeOf.Kind()

        // Create input adapter
        var inputAdap sliceInputAdapter
        expectedType := reflect.TypeOf((*T)(nil)).Elem()

        if kind == reflect.Chan </span><span class="cov5" title="16">{
                maxLen := v.getMaxLen()
                // Try to create typed channel adapter
                chanAdap, err := newChannelInputAdapter[T](input, maxLen)
                if err != nil </span><span class="cov2" title="3">{
                        return err
                }</span>
                <span class="cov5" title="13">inputAdap = chanAdap</span>
        } else<span class="cov7" title="47"> if kind == reflect.Slice || kind == reflect.Array </span><span class="cov7" title="45">{
                inputAdap = newSliceInputAdapter(valueOf)
        }</span> else<span class="cov2" title="2"> {
                return errors.Collection(errors.NewCoercionError(ctx, "array", kind.String()))
        }</span>

        // Create output adapter
        <span class="cov7" title="58">outputElem := outputVal.Elem()
        var outputAdap sliceOutputAdapter[T]
        if outputElem.Kind() == reflect.Chan </span><span class="cov5" title="16">{
                // Try to create typed channel adapter
                chanAdap, err := newChannelOutputAdapter[T](outputElem.Interface())
                if err != nil </span><span class="cov3" title="4">{
                        return err
                }</span>
                <span class="cov4" title="12">outputAdap = chanAdap</span>
        } else<span class="cov6" title="42"> {
                var err errors.ValidationErrorCollection
                outputAdap, err = newSliceOutputAdapter[T](outputVal, expectedType)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Check for an item RuleSet
        <span class="cov7" title="54">var itemRuleSet RuleSet[T]
        for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov7" title="77">{
                if currentRuleSet.itemRules != nil </span><span class="cov5" title="15">{
                        itemRuleSet = currentRuleSet.itemRules
                        break</span>
                }
        }

        // Collect all items from input
        <span class="cov7" title="54">var items []reflect.Value
        var allErrors = errors.Collection()
        knownLength := inputAdap.length()

        // Pre-allocate items slice if length is known
        if knownLength &gt;= 0 </span><span class="cov6" title="41">{
                items = make([]reflect.Value, 0, knownLength)
        }</span>

        <span class="cov7" title="54">for </span><span class="cov10" title="286">{
                item, done, err := inputAdap.next(ctx)
                if err != nil </span><span class="cov2" title="3">{
                        allErrors = append(allErrors, err...)
                        if outputAdap != nil </span><span class="cov2" title="3">{
                                outputAdap.finalize(ctx, len(items))
                        }</span>
                        <span class="cov2" title="3">return allErrors</span>
                }
                <span class="cov9" title="283">if done </span><span class="cov7" title="51">{
                        break</span>
                }
                <span class="cov9" title="232">items = append(items, item)</span>
        }

        // If no items, finalize empty output
        <span class="cov7" title="51">if len(items) == 0 </span><span class="cov2" title="2">{
                if err := outputAdap.finalize(ctx, 0); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">return nil</span>
        }

        // Process items (with ordered buffering for concurrent validation)
        <span class="cov7" title="49">type itemResult struct {
                index int
                value T
                err   errors.ValidationErrorCollection
        }

        results := make([]itemResult, len(items))
        resultChan := make(chan itemResult, len(items))

        // Process items concurrently if we have item rules
        if itemRuleSet != nil </span><span class="cov5" title="15">{
                var wg sync.WaitGroup
                for i, item := range items </span><span class="cov7" title="46">{
                        wg.Add(1)
                        go func(idx int, itemVal reflect.Value) </span><span class="cov7" title="46">{
                                defer wg.Done()

                                subContext := rulecontext.WithPathIndex(ctx, idx)
                                itemInterface := itemVal.Interface()

                                var itemOutput T
                                itemErr := itemRuleSet.Apply(subContext, itemInterface, &amp;itemOutput)

                                // If validation failed, try to use the original input value (coerced if possible)
                                // This ensures all items appear in output even if validation fails
                                if itemErr != nil </span><span class="cov4" title="11">{
                                        // Try to cast the original item to T
                                        if castItem, castOk := itemInterface.(T); castOk </span><span class="cov4" title="11">{
                                                itemOutput = castItem
                                        }</span>
                                        // If cast fails, itemOutput remains zero value, which is fine
                                }

                                <span class="cov7" title="45">resultChan &lt;- itemResult{
                                        index: idx,
                                        value: itemOutput,
                                        err:   itemErr,
                                }</span>
                        }(i, item)
                }

                // Wait for all goroutines to complete or context cancellation
                <span class="cov5" title="15">done := make(chan struct{})
                go func() </span><span class="cov5" title="15">{
                        wg.Wait()
                        close(done)
                }</span>()

                <span class="cov5" title="15">select </span>{
                case &lt;-ctx.Done():<span class="cov2" title="2">
                        allErrors = append(allErrors, contextErrorToValidation(ctx))
                        if err := outputAdap.finalize(ctx, len(items)); err != nil </span><span class="cov0" title="0">{
                                allErrors = append(allErrors, err...)
                        }</span>
                        <span class="cov2" title="2">return allErrors</span>
                case &lt;-done:<span class="cov5" title="13"></span>
                }

                // Collect results in order
                <span class="cov5" title="13">for i := 0; i &lt; len(items); i++ </span><span class="cov6" title="38">{
                        result := &lt;-resultChan
                        results[result.index] = result
                }</span>
        } else<span class="cov6" title="34"> {
                // Sequential processing without item rules (just casting)
                expected := ""
                for i, item := range items </span><span class="cov9" title="186">{
                        itemInterface := item.Interface()
                        castItem, castOk := itemInterface.(T)
                        if !castOk </span><span class="cov3" title="5">{
                                subContext := rulecontext.WithPathString(ctx, strconv.Itoa(i))
                                if expected == "" </span><span class="cov2" title="2">{
                                        expected = reflect.TypeOf(new(T)).Elem().Name()
                                }</span>
                                <span class="cov3" title="5">actual := item.Kind().String()
                                allErrors = append(allErrors, errors.NewCoercionError(subContext, expected, actual))</span>
                        }
                        <span class="cov9" title="186">results[i] = itemResult{
                                index: i,
                                value: castItem,
                                err:   nil,
                        }</span>
                }
        }

        // Write results to output adapter
        <span class="cov7" title="47">for i, result := range results </span><span class="cov9" title="222">{
                if err := outputAdap.putIndex(ctx, i, result.value); err != nil </span><span class="cov2" title="2">{
                        allErrors = append(allErrors, err...)
                        if err := outputAdap.finalize(ctx, len(results)); err != nil </span><span class="cov0" title="0">{
                                allErrors = append(allErrors, err...)
                        }</span>
                        <span class="cov2" title="2">return allErrors</span>
                }
                <span class="cov9" title="220">if result.err != nil </span><span class="cov4" title="11">{
                        allErrors = append(allErrors, result.err...)
                }</span>
        }

        // Build output slice for array-level rule evaluation
        <span class="cov7" title="45">outputSlice := reflect.MakeSlice(reflect.SliceOf(expectedType), len(results), len(results))
        for i, result := range results </span><span class="cov9" title="218">{
                outputSlice.Index(i).Set(reflect.ValueOf(result.value))
        }</span>

        // Apply array-level rules after all items are validated and cast
        <span class="cov7" title="45">for currentRuleSet := v; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov7" title="81">{
                if currentRuleSet.rule != nil </span><span class="cov5" title="23">{
                        if err := currentRuleSet.rule.Evaluate(ctx, outputSlice.Interface().([]T)); err != nil </span><span class="cov3" title="6">{
                                allErrors = append(allErrors, err...)
                        }</span>
                }
        }

        // Finalize output
        <span class="cov7" title="45">if err := outputAdap.finalize(ctx, len(results)); err != nil </span><span class="cov3" title="4">{
                allErrors = append(allErrors, err...)
        }</span>

        // Return any accumulated errors
        <span class="cov7" title="45">if len(allErrors) != 0 </span><span class="cov5" title="17">{
                return allErrors
        }</span>

        <span class="cov6" title="28">return nil</span>
}

// Evaluate performs validation of a RuleSet against a slice type and returns a ValidationErrorCollection.
func (ruleSet *SliceRuleSet[T]) Evaluate(ctx context.Context, value []T) errors.ValidationErrorCollection <span class="cov1" title="1">{
        var out any
        return ruleSet.Apply(ctx, value, &amp;out)
}</span>

// noConflict returns the new array rule set with all conflicting rules removed.
// Does not mutate the existing rule sets.
func (ruleSet *SliceRuleSet[T]) noConflict(rule Rule[[]T]) *SliceRuleSet[T] <span class="cov5" title="20">{

        if ruleSet.rule != nil </span><span class="cov4" title="7">{

                // Conflicting rules, skip this and return the parent
                if rule.Conflict(ruleSet.rule) </span><span class="cov2" title="2">{
                        return ruleSet.parent.noConflict(rule)
                }</span>

        }

        <span class="cov5" title="18">if ruleSet.parent == nil </span><span class="cov4" title="12">{
                return ruleSet
        }</span>

        <span class="cov3" title="6">newParent := ruleSet.parent.noConflict(rule)

        if newParent == ruleSet.parent </span><span class="cov3" title="4">{
                return ruleSet
        }</span>

        <span class="cov2" title="2">return &amp;SliceRuleSet[T]{
                rule:      ruleSet.rule,
                parent:    newParent,
                required:  ruleSet.required,
                withNil:   ruleSet.withNil,
                itemRules: ruleSet.itemRules,
                label:     ruleSet.label,
        }</span>
}

// WithRule returns a new child rule set that applies a custom validation rule.
// The custom rule is evaluated during validation and any errors it returns are included in the validation result.
func (v *SliceRuleSet[T]) WithRule(rule Rule[[]T]) *SliceRuleSet[T] <span class="cov4" title="12">{
        return &amp;SliceRuleSet[T]{
                rule:     rule,
                parent:   v.noConflict(rule),
                required: v.required,
                withNil:  v.withNil,
        }
}</span>

// WithRuleFunc returns a new child rule set that applies a custom validation function.
// The custom function is evaluated during validation and any errors it returns are included in the validation result.
func (v *SliceRuleSet[T]) WithRuleFunc(rule RuleFunc[[]T]) *SliceRuleSet[T] <span class="cov2" title="2">{
        return v.WithRule(rule)
}</span>

// Any returns a new RuleSet that wraps the slice RuleSet in an Any rule set
// which can then be used in nested validation.
func (v *SliceRuleSet[T]) Any() RuleSet[any] <span class="cov1" title="1">{
        return WrapAny[[]T](v)
}</span>

// String returns a string representation of the rule set suitable for debugging.
func (ruleSet *SliceRuleSet[T]) String() string <span class="cov5" title="16">{
        label := ruleSet.label

        if label == "" </span><span class="cov4" title="9">{
                if ruleSet.rule != nil </span><span class="cov4" title="8">{
                        label = ruleSet.rule.String()
                }</span> else<span class="cov1" title="1"> if ruleSet.itemRules != nil </span><span class="cov1" title="1">{
                        label = fmt.Sprintf("WithItemRuleSet(%s)", ruleSet.itemRules)
                }</span>
        }

        <span class="cov5" title="16">if ruleSet.parent != nil </span><span class="cov4" title="10">{
                return ruleSet.parent.String() + "." + label
        }</span>
        <span class="cov3" title="6">return label</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package rules

import (
        "context"
        "reflect"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
        "proto.zip/studio/validate/pkg/rulecontext"
)

// Implementation of RuleSet for strings.
type StringRuleSet struct {
        NoConflict[string]
        strict   bool
        rule     Rule[string]
        required bool
        withNil  bool
        parent   *StringRuleSet
        label    string
}

// baseStringRuleSet is the main RuleSet.
// New returns this since rule sets are immutable and StringRuleSet does not contain generics.
var baseStringRuleSet StringRuleSet = StringRuleSet{
        label: "StringRuleSet",
}

// String returns the base StringRuleSet.
func String() *StringRuleSet <span class="cov7" title="87">{
        return &amp;baseStringRuleSet
}</span>

// WithStrict returns a new child RuleSet that disables type coercion.
// When strict mode is enabled, validation only succeeds if the value is already a string.
func (v *StringRuleSet) WithStrict() *StringRuleSet <span class="cov3" title="4">{
        return &amp;StringRuleSet{
                strict:   true,
                parent:   v,
                required: v.required,
                withNil:  v.withNil,
                label:    "WithStrict()",
        }
}</span>

// Required returns a boolean indicating if the value is allowed to be omitted when included in a nested object.
func (v *StringRuleSet) Required() bool <span class="cov6" title="47">{
        return v.required
}</span>

// WithRequired returns a new child rule set that requires the value to be present when nested in an object.
// When a required field is missing from the input, validation fails with an error.
func (v *StringRuleSet) WithRequired() *StringRuleSet <span class="cov3" title="6">{
        return &amp;StringRuleSet{
                strict:   v.strict,
                parent:   v,
                required: true,
                withNil:  v.withNil,
                label:    "WithRequired()",
        }
}</span>

// WithNil returns a new child rule set that allows nil input values.
// When nil input is provided, validation passes and the output is set to nil (if the output type supports nil values).
// By default, nil input values return a CodeNull error.
func (v *StringRuleSet) WithNil() *StringRuleSet <span class="cov2" title="2">{
        return &amp;StringRuleSet{
                strict:   v.strict,
                parent:   v,
                required: v.required,
                withNil:  true,
                label:    "WithNil()",
        }
}</span>

// Apply performs validation of a RuleSet against a value and assigns the resulting string to the output pointer.
// Apply returns a ValidationErrorCollection.
func (v *StringRuleSet) Apply(ctx context.Context, value, output any) errors.ValidationErrorCollection <span class="cov8" title="160">{
        // Check if withNil is enabled and value is nil
        if handled, err := util.TrySetNilIfAllowed(ctx, v.withNil, value, output); handled </span><span class="cov2" title="3">{
                return err
        }</span>

        // Ensure output is a pointer that can be set
        <span class="cov8" title="157">rv := reflect.ValueOf(output)
        if rv.Kind() != reflect.Ptr || rv.IsNil() </span><span class="cov2" title="3">{
                return errors.Collection(
                        errors.Errorf(errors.CodeInternal, ctx, "Output must be a non-nil pointer"),
                )
        }</span>

        // Attempt to coerce the input to a string
        <span class="cov8" title="154">str, validationErr := v.coerce(value, ctx)

        if validationErr != nil </span><span class="cov3" title="4">{
                return errors.Collection(validationErr)
        }</span>

        <span class="cov8" title="150">verrs := v.Evaluate(ctx, str)
        if verrs != nil </span><span class="cov6" title="54">{
                return verrs
        }</span>

        // Set the string result in the output parameter
        <span class="cov7" title="95">elem := rv.Elem()

        // Check if the output is an interface
        if elem.Kind() == reflect.Interface </span><span class="cov6" title="54">{
                // Create a new string value and set the interface to point to it
                elem.Set(reflect.ValueOf(str))
                return nil
        }</span>

        // If the element is a string, replace it with the new string value
        <span class="cov6" title="41">if elem.Kind() == reflect.String </span><span class="cov6" title="40">{
                elem.SetString(str)
                return nil
        }</span>

        <span class="cov1" title="1">return errors.Collection(
                errors.Errorf(errors.CodeInternal, ctx, "Cannot assign string to %T", output),
        )</span>
}

// Evaluate performs validation of a RuleSet against a string value and returns a ValidationErrorCollection.
func (v *StringRuleSet) Evaluate(ctx context.Context, value string) errors.ValidationErrorCollection <span class="cov8" title="214">{
        allErrors := errors.Collection()

        currentRuleSet := v
        ctx = rulecontext.WithRuleSet(ctx, v)

        for currentRuleSet != nil </span><span class="cov10" title="435">{
                if currentRuleSet.rule != nil </span><span class="cov8" title="215">{
                        if errs := currentRuleSet.rule.Evaluate(ctx, value); errs != nil </span><span class="cov7" title="82">{
                                allErrors = append(allErrors, errs...)
                        }</span>
                }

                <span class="cov9" title="434">currentRuleSet = currentRuleSet.parent</span>
        }

        <span class="cov8" title="213">if len(allErrors) &gt; 0 </span><span class="cov7" title="82">{
                return allErrors
        }</span> else<span class="cov8" title="131"> {
                return nil
        }</span>
}

// noConflict returns the new array rule set with all conflicting rules removed.
// Does not mutate the existing rule sets.
func (ruleSet *StringRuleSet) noConflict(rule Rule[string]) *StringRuleSet <span class="cov7" title="111">{
        if ruleSet.rule != nil </span><span class="cov5" title="29">{

                // Conflicting rules, skip this and return the parent
                if rule.Conflict(ruleSet.rule) </span><span class="cov4" title="13">{
                        return ruleSet.parent.noConflict(rule)
                }</span>

        }

        <span class="cov7" title="98">if ruleSet.parent == nil </span><span class="cov7" title="80">{
                return ruleSet
        }</span>

        <span class="cov5" title="18">newParent := ruleSet.parent.noConflict(rule)

        if newParent == ruleSet.parent </span><span class="cov4" title="11">{
                return ruleSet
        }</span>

        <span class="cov3" title="7">return &amp;StringRuleSet{
                rule:     ruleSet.rule,
                parent:   newParent,
                required: ruleSet.required,
                strict:   ruleSet.strict,
                withNil:  ruleSet.withNil,
                label:    ruleSet.label,
        }</span>
}

// WithRule returns a new child rule set that applies a custom validation rule.
// The custom rule is evaluated during validation and any errors it returns are included in the validation result.
func (ruleSet *StringRuleSet) WithRule(rule Rule[string]) *StringRuleSet <span class="cov7" title="80">{
        return &amp;StringRuleSet{
                strict:   ruleSet.strict,
                rule:     rule,
                parent:   ruleSet.noConflict(rule),
                required: ruleSet.required,
                withNil:  ruleSet.withNil,
        }
}</span>

// WithRuleFunc returns a new child rule set that applies a custom validation function.
// The custom function is evaluated during validation and any errors it returns are included in the validation result.
func (v *StringRuleSet) WithRuleFunc(rule RuleFunc[string]) *StringRuleSet <span class="cov3" title="4">{
        return v.WithRule(rule)
}</span>

// Any returns a new RuleSet that wraps the string RuleSet in an Any rule set
// which can then be used in nested validation.
func (v *StringRuleSet) Any() RuleSet[any] <span class="cov6" title="45">{
        return WrapAny[string](v)
}</span>

// String returns a string representation of the rule set suitable for debugging.
func (ruleSet *StringRuleSet) String() string <span class="cov7" title="78">{
        label := ruleSet.label

        if label == "" &amp;&amp; ruleSet.rule != nil </span><span class="cov6" title="45">{
                label = ruleSet.rule.String()
        }</span>

        <span class="cov7" title="78">if ruleSet.parent != nil </span><span class="cov6" title="47">{
                return ruleSet.parent.String() + "." + label
        }</span>
        <span class="cov6" title="31">return label</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package rules

import (
        "context"
        "fmt"
        "reflect"
        "strconv"

        "proto.zip/studio/validate/pkg/errors"
)

func (v *StringRuleSet) coerce(value any, ctx context.Context) (string, errors.ValidationError) <span class="cov10" title="154">{
        str, ok := value.(string)

        if ok </span><span class="cov9" title="141">{
                return str, nil
        }</span>
        <span class="cov5" title="13">if v.strict </span><span class="cov2" title="3">{
                return "", errors.NewCoercionError(ctx, "string", reflect.TypeOf(value).String())
        }</span>

        <span class="cov5" title="10">switch x := value.(type) </span>{
        case int:<span class="cov2" title="3">
                return strconv.Itoa(x), nil</span>
        case *int:<span class="cov1" title="1">
                return strconv.Itoa(*x), nil</span>
        case int64:<span class="cov1" title="1">
                return strconv.FormatInt(x, 10), nil</span>
        case *int64:<span class="cov1" title="1">
                return strconv.FormatInt(*x, 10), nil</span>
        case float64:<span class="cov1" title="1">
                return fmt.Sprintf("%v", x), nil</span>
        case *float64:<span class="cov1" title="1">
                return fmt.Sprintf("%v", *x), nil</span>
        case *string:<span class="cov1" title="1">
                return *x, nil</span>
        }

        <span class="cov1" title="1">return "", errors.NewCoercionError(ctx, "string", reflect.TypeOf(value).String())</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for maximum string value (lexicographical comparison)
type stringMaxRule struct {
        max string
}

// Evaluate takes a context and string value and returns an error if it is lexicographically greater than the specified maximum value.
func (rule *stringMaxRule) Evaluate(ctx context.Context, value string) errors.ValidationErrorCollection <span class="cov10" title="17">{
        if value &gt; rule.max </span><span class="cov6" title="6">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMax, ctx, "value must be less than or equal to %q", truncateString(rule.max)),
                )
        }</span>

        <span class="cov8" title="11">return nil</span>
}

// Conflict returns true for any maximum or exclusive maximum string value rule.
func (rule *stringMaxRule) Conflict(x Rule[string]) bool <span class="cov5" title="4">{
        _, ok1 := x.(*stringMaxRule)
        _, ok2 := x.(*stringMaxExclusiveRule)
        return ok1 || ok2
}</span>

// String returns the string representation of the maximum string value rule.
// Example: WithMax("xyz")
func (rule *stringMaxRule) String() string <span class="cov6" title="5">{
        return fmt.Sprintf("WithMax(%q)", rule.max)
}</span>

// WithMax returns a new child RuleSet that is constrained to the provided maximum string value (inclusive).
// Strings are compared using lexicographical comparison.
func (v *StringRuleSet) WithMax(max string) *StringRuleSet <span class="cov7" title="8">{
        return v.WithRule(&amp;stringMaxRule{
                max: max,
        })
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for exclusive maximum string value (lexicographical comparison)
type stringMaxExclusiveRule struct {
        max string
}

// Evaluate takes a context and string value and returns an error if it is lexicographically greater than or equal to the specified value.
func (rule *stringMaxExclusiveRule) Evaluate(ctx context.Context, value string) errors.ValidationErrorCollection <span class="cov10" title="20">{
        if value &gt;= rule.max </span><span class="cov8" title="11">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMax, ctx, "value must be less than %q", truncateString(rule.max)),
                )
        }</span>

        <span class="cov7" title="9">return nil</span>
}

// Conflict returns true for any maximum or exclusive maximum string value rule.
func (rule *stringMaxExclusiveRule) Conflict(x Rule[string]) bool <span class="cov5" title="4">{
        _, ok1 := x.(*stringMaxRule)
        _, ok2 := x.(*stringMaxExclusiveRule)
        return ok1 || ok2
}</span>

// String returns the string representation of the exclusive maximum string value rule.
// Example: WithMaxExclusive("xyz")
func (rule *stringMaxExclusiveRule) String() string <span class="cov5" title="5">{
        return fmt.Sprintf("WithMaxExclusive(%q)", rule.max)
}</span>

// WithMaxExclusive returns a new child RuleSet that is constrained to values less than the provided string value (exclusive).
// Strings are compared using lexicographical comparison.
func (v *StringRuleSet) WithMaxExclusive(max string) *StringRuleSet <span class="cov6" title="7">{
        return v.WithRule(&amp;stringMaxExclusiveRule{
                max: max,
        })
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

const maxStringDisplayLength = 50

// truncateString truncates a string to a maximum length, adding ellipsis if truncated.
func truncateString(s string) string <span class="cov10" title="30">{
        if len(s) &lt;= maxStringDisplayLength </span><span class="cov9" title="28">{
                return s
        }</span>
        <span class="cov2" title="2">return s[:maxStringDisplayLength] + "..."</span>
}

// Implements the Rule interface for minimum string value (lexicographical comparison)
type stringMinRule struct {
        min string
}

// Evaluate takes a context and string value and returns an error if it is lexicographically less than the specified minimum value.
func (rule *stringMinRule) Evaluate(ctx context.Context, value string) errors.ValidationErrorCollection <span class="cov8" title="17">{
        if value &lt; rule.min </span><span class="cov4" title="4">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMin, ctx, "value must be greater than or equal to %q", truncateString(rule.min)),
                )
        }</span>

        <span class="cov7" title="13">return nil</span>
}

// Conflict returns true for any minimum or exclusive minimum string value rule.
func (rule *stringMinRule) Conflict(x Rule[string]) bool <span class="cov4" title="4">{
        _, ok1 := x.(*stringMinRule)
        _, ok2 := x.(*stringMinExclusiveRule)
        return ok1 || ok2
}</span>

// String returns the string representation of the minimum string value rule.
// Example: WithMin("abc")
func (rule *stringMinRule) String() string <span class="cov5" title="5">{
        return fmt.Sprintf("WithMin(%q)", rule.min)
}</span>

// WithMin returns a new child RuleSet that is constrained to the provided minimum string value (inclusive).
// Strings are compared using lexicographical comparison.
func (v *StringRuleSet) WithMin(min string) *StringRuleSet <span class="cov6" title="8">{
        return v.WithRule(&amp;stringMinRule{
                min: min,
        })
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package rules

import (
        "context"
        "fmt"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for exclusive minimum string value (lexicographical comparison)
type stringMinExclusiveRule struct {
        min string
}

// Evaluate takes a context and string value and returns an error if it is lexicographically less than or equal to the specified value.
func (rule *stringMinExclusiveRule) Evaluate(ctx context.Context, value string) errors.ValidationErrorCollection <span class="cov10" title="20">{
        if value &lt;= rule.min </span><span class="cov7" title="9">{
                return errors.Collection(
                        errors.Errorf(errors.CodeMin, ctx, "value must be greater than %q", truncateString(rule.min)),
                )
        }</span>

        <span class="cov8" title="11">return nil</span>
}

// Conflict returns true for any minimum or exclusive minimum string value rule.
func (rule *stringMinExclusiveRule) Conflict(x Rule[string]) bool <span class="cov5" title="4">{
        _, ok1 := x.(*stringMinRule)
        _, ok2 := x.(*stringMinExclusiveRule)
        return ok1 || ok2
}</span>

// String returns the string representation of the exclusive minimum string value rule.
// Example: WithMinExclusive("abc")
func (rule *stringMinExclusiveRule) String() string <span class="cov5" title="5">{
        return fmt.Sprintf("WithMinExclusive(%q)", rule.min)
}</span>

// WithMinExclusive returns a new child RuleSet that is constrained to values greater than the provided string value (exclusive).
// Strings are compared using lexicographical comparison.
func (v *StringRuleSet) WithMinExclusive(min string) *StringRuleSet <span class="cov6" title="7">{
        return v.WithRule(&amp;stringMinExclusiveRule{
                min: min,
        })
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package rules

import (
        "context"
        "fmt"
        "regexp"

        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for regular expressions.
type regexpRule struct {
        NoConflict[string]
        exp *regexp.Regexp
        msg string
}

// Evaluate takes a context and string value and returns an error if it does not match the expected pattern.
func (rule *regexpRule) Evaluate(ctx context.Context, value string) errors.ValidationErrorCollection <span class="cov10" title="68">{
        if !rule.exp.MatchString(value) </span><span class="cov8" title="30">{
                return errors.Collection(
                        errors.Errorf(errors.CodePattern, ctx, rule.msg),
                )
        }</span>

        <span class="cov8" title="38">return nil</span>
}

// String returns the string representation of the regex rule.
// Example: WithRegexp(2)
func (rule *regexpRule) String() string <span class="cov2" title="2">{
        return fmt.Sprintf("WithRegexp(%s)", rule.exp)
}</span>

// WithRegexpString returns a new child RuleSet that is constrained to the provided regular expression.
// The second parameter is the error text, which will be localized if a translation is available.
//
// This method panics if the expression cannot be compiled.
func (v *StringRuleSet) WithRegexpString(exp, errorMsg string) *StringRuleSet <span class="cov3" title="4">{
        return v.WithRegexp(regexp.MustCompile(exp), errorMsg)
}</span>

// WithRegexp returns a new child RuleSet that is constrained to the provided regular expression.
// The second parameter is the error text, which will be localized if a translation is available.
func (v *StringRuleSet) WithRegexp(exp *regexp.Regexp, errorMsg string) *StringRuleSet <span class="cov7" title="20">{
        return v.WithRule(&amp;regexpRule{
                exp: exp,
                msg: errorMsg,
        })
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package rules

import (
        "context"
        "slices"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
)

// Implements the Rule interface for an allowed list of values.
type stringValuesRule struct {
        values []string
        allow  bool
}

// exists returns true if the value exists in the rule
func (rule *stringValuesRule) exists(value string) bool <span class="cov8" title="18">{
        low, high := 0, len(rule.values)-1

        for low &lt;= high </span><span class="cov10" title="26">{
                mid := (low + high) / 2

                if rule.values[mid] == value </span><span class="cov8" title="13">{
                        return true
                }</span>

                <span class="cov8" title="13">if rule.values[mid] &lt; value </span><span class="cov7" title="9">{
                        low = mid + 1
                }</span> else<span class="cov4" title="4"> {
                        high = mid - 1
                }</span>
        }

        <span class="cov5" title="5">return false</span>
}

// Evaluate takes a context and string value and returns an error depending on whether the value is in a list
// of allowed or denied values.
func (rule *stringValuesRule) Evaluate(ctx context.Context, value string) errors.ValidationErrorCollection <span class="cov8" title="18">{
        exists := rule.exists(value)

        if rule.allow </span><span class="cov7" title="11">{
                if !exists </span><span class="cov2" title="2">{
                        return errors.Collection(
                                errors.Errorf(errors.CodeNotAllowed, ctx, "field value is not allowed"),
                        )
                }</span>
        } else<span class="cov6" title="7"> if exists </span><span class="cov4" title="4">{
                return errors.Collection(
                        errors.Errorf(errors.CodeForbidden, ctx, "field value is not allowed"),
                )
        }</span>

        <span class="cov7" title="12">return nil</span>
}

// Conflict returns two for allow rules and always returns false for deny rules.
func (rule *stringValuesRule) Conflict(x Rule[string]) bool <span class="cov5" title="5">{
        if !rule.allow </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov4" title="4">if other, ok := x.(*stringValuesRule); ok </span><span class="cov4" title="3">{
                return other.allow
        }</span>
        <span class="cov1" title="1">return false</span>
}

// String returns the string representation of the values rule.
// Example: WithAllowedValues("b", "b", "c")
func (rule *stringValuesRule) String() string <span class="cov6" title="8">{
        if !rule.allow </span><span class="cov4" title="3">{
                return util.StringsToRuleOutput("WithRejectedValues", rule.values)

        }</span>
        <span class="cov5" title="5">return util.StringsToRuleOutput("WithAllowedValues", rule.values)</span>
}

// getValuesRule returns the previous defined values rule for the rule set that has the expected value for "allow".
// Returns nil if there is none.
func (ruleSet *StringRuleSet) getValuesRule(allow bool) *stringValuesRule <span class="cov6" title="7">{
        for currentRuleSet := ruleSet; currentRuleSet != nil; currentRuleSet = currentRuleSet.parent </span><span class="cov7" title="10">{
                if currentRuleSet.rule == nil </span><span class="cov5" title="6">{
                        continue</span>
                }

                <span class="cov4" title="4">if valueRule, ok := currentRuleSet.rule.(*stringValuesRule); ok &amp;&amp; valueRule.allow == allow </span><span class="cov4" title="3">{
                        return valueRule
                }</span>
        }
        <span class="cov4" title="4">return nil</span>
}

// WithAllowedValues returns a new child RuleSet that is checked against the provided list of allowed values.
//
// This method can be called more than once and the allowed values are cumulative.
// Allowed values must still pass all other rules.
func (ruleSet *StringRuleSet) WithAllowedValues(value string, rest ...string) *StringRuleSet <span class="cov6" title="7">{
        existing := ruleSet.getValuesRule(true)
        l := 1 + len(rest)

        if existing != nil </span><span class="cov4" title="3">{
                l += len(existing.values)
        }</span>

        <span class="cov6" title="7">values := make([]string, 0, l)
        values = append(values, value)
        values = append(values, rest...)

        // Get previous rule if there is one
        if existing != nil </span><span class="cov4" title="3">{
                values = append(values, existing.values...)
        }</span>

        <span class="cov6" title="7">slices.Sort(values)

        return ruleSet.WithRule(&amp;stringValuesRule{
                values,
                true,
        })</span>
}

// WithRejectedValues returns a new child RuleSet that is checked against the provided list of values hat should be rejected.
// This method can be called more than once.
//
// Rejected values will always be rejected even if they are in the allowed values list.
func (ruleSet *StringRuleSet) WithRejectedValues(value string, rest ...string) *StringRuleSet <span class="cov2" title="2">{
        values := make([]string, 0, 1+len(rest))
        values = append(values, value)
        values = append(values, rest...)

        slices.Sort(values)

        return ruleSet.WithRule(&amp;stringValuesRule{
                values,
                false,
        })
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package rules

import (
        "context"

        "proto.zip/studio/validate/internal/util"
        "proto.zip/studio/validate/pkg/errors"
        "proto.zip/studio/validate/pkg/rulecontext"
)

// WrapAnyRuleSet implements RuleSet for the "any" interface and wraps around another type of rule set.
// Use it when you need to use a more specific RuleSet in a nested validator or to pass into a function.
//
// Unless you are implementing a brand new RuleSet you probably want to use the .Any() method on the RuleSet
// itself instead, which usually returns this interface.
type WrapAnyRuleSet[T any] struct {
        NoConflict[any]
        required bool
        withNil  bool
        inner    RuleSet[T]
        rule     Rule[any]
        parent   *WrapAnyRuleSet[T]
        label    string
}

// WrapAny wraps an existing RuleSet in an "Any" rule set which can then be used to pass into nested validators
// or any function where the type of RuleSet is not known ahead of time.
//
// WrapAny is usually called by the .Any() method on RuleSet implementations.
// Unless you are implementing a brand new RuleSet you probably want to use the .Any() method instead.
func WrapAny[T any](inner RuleSet[T]) *WrapAnyRuleSet[T] <span class="cov8" title="258">{
        return &amp;WrapAnyRuleSet[T]{
                required: inner.Required(),
                inner:    inner,
        }
}</span>

// Required returns a boolean indicating if the value is allowed to be omitted when included in a nested object.
func (v *WrapAnyRuleSet[T]) Required() bool <span class="cov4" title="9">{
        return v.required
}</span>

// WithRequired returns a new child rule set that requires the value to be present when nested in an object.
// When a required field is missing from the input, validation fails with an error.
//
// Required defaults to the value of the wrapped RuleSet so if it is already required then there is
// no need to call this again.
func (v *WrapAnyRuleSet[T]) WithRequired() *WrapAnyRuleSet[T] <span class="cov2" title="3">{
        return &amp;WrapAnyRuleSet[T]{
                required: true,
                withNil:  v.withNil,
                inner:    v.inner,
                parent:   v,
                label:    "WithRequired()",
        }
}</span>

// WithNil returns a new child rule set that allows nil input values.
// When nil input is provided, validation passes and the output is set to nil (if the output type supports nil values).
// By default, nil input values return a CodeNull error.
func (v *WrapAnyRuleSet[T]) WithNil() *WrapAnyRuleSet[T] <span class="cov1" title="2">{
        return &amp;WrapAnyRuleSet[T]{
                required: v.required,
                withNil:  true,
                inner:    v.inner,
                parent:   v,
                label:    "WithNil()",
        }
}</span>

// evaluateRules runs all the rules and returns any errors.
// Returns a collection regardless of if there are any errors.
func (v *WrapAnyRuleSet[T]) evaluateRules(ctx context.Context, value any) errors.ValidationErrorCollection <span class="cov9" title="531">{
        allErrors := errors.Collection()

        currentRuleSet := v
        ctx = rulecontext.WithRuleSet(ctx, v)

        for currentRuleSet != nil </span><span class="cov10" title="533">{
                if currentRuleSet.rule != nil </span><span class="cov1" title="2">{
                        if errs := currentRuleSet.rule.Evaluate(ctx, value); errs != nil </span><span class="cov1" title="1">{
                                allErrors = append(allErrors, errs...)
                        }</span>
                }

                <span class="cov10" title="533">currentRuleSet = currentRuleSet.parent</span>
        }

        <span class="cov9" title="531">return allErrors</span>
}

// Apply performs validation of a RuleSet against a value and assigns the result to the output parameter.
// Apply calls wrapped rules before any rules added directly to the WrapAnyRuleSet.
// Apply returns a ValidationErrorCollection if any validation errors occur.
func (v *WrapAnyRuleSet[T]) Apply(ctx context.Context, input, output any) errors.ValidationErrorCollection <span class="cov9" title="532">{
        // Check if withNil is enabled and input is nil
        if handled, err := util.TrySetNilIfAllowed(ctx, v.withNil, input, output); handled </span><span class="cov2" title="3">{
                return err
        }</span>

        <span class="cov9" title="529">innerErrors := v.inner.Apply(ctx, input, output)
        allErrors := v.evaluateRules(ctx, output)

        if innerErrors != nil </span><span class="cov8" title="153">{
                allErrors = append(allErrors, innerErrors...)
        }</span>

        <span class="cov9" title="529">if len(allErrors) &gt; 0 </span><span class="cov8" title="154">{
                return allErrors
        }</span> else<span class="cov9" title="375"> {
                return nil
        }</span>
}

// Evaluate performs validation of a RuleSet against a value of any type and returns a ValidationErrorCollection.
// Evaluate calls the wrapped RuleSet's Evaluate method directly if the input value implements the same type,
// otherwise it calls Apply. This approach is usually more efficient since it does not need to allocate an output variable.
func (ruleSet *WrapAnyRuleSet[T]) Evaluate(ctx context.Context, value any) errors.ValidationErrorCollection <span class="cov2" title="4">{
        if v, ok := value.(T); ok </span><span class="cov1" title="2">{
                innerErrors := ruleSet.inner.Evaluate(ctx, v)
                allErrors := ruleSet.evaluateRules(ctx, value)

                if innerErrors != nil </span><span class="cov1" title="1">{
                        allErrors = append(allErrors, innerErrors...)
                }</span>

                <span class="cov1" title="2">if len(allErrors) != 0 </span><span class="cov1" title="1">{
                        return allErrors
                }</span> else<span class="cov1" title="1"> {
                        return nil
                }</span>
        } else<span class="cov1" title="2"> {
                var out T
                errs := ruleSet.Apply(ctx, value, &amp;out)
                return errs
        }</span>
}

// WithRule returns a new child rule set that applies a custom validation rule.
// The custom rule is evaluated during validation and any errors it returns are included in the validation result.
//
// If you want to add a rule directly to the wrapped RuleSet you must do it before wrapping it.
func (v *WrapAnyRuleSet[T]) WithRule(rule Rule[any]) *WrapAnyRuleSet[T] <span class="cov2" title="3">{
        return &amp;WrapAnyRuleSet[T]{
                required: v.required,
                withNil:  v.withNil,
                inner:    v.inner,
                rule:     rule,
                parent:   v,
        }
}</span>

// WithRuleFunc returns a new child rule set that applies a custom validation function.
// The custom function is evaluated during validation and any errors it returns are included in the validation result.
//
// If you want to add a rule directly to the wrapped RuleSet you must do it before wrapping it.
func (v *WrapAnyRuleSet[T]) WithRuleFunc(rule RuleFunc[any]) *WrapAnyRuleSet[T] <span class="cov1" title="1">{
        return v.WithRule(rule)
}</span>

// Any returns the current rule set.
func (v *WrapAnyRuleSet[T]) Any() RuleSet[any] <span class="cov5" title="25">{
        return v
}</span>

// String returns a string representation of the rule set suitable for debugging.
func (ruleSet *WrapAnyRuleSet[T]) String() string <span class="cov4" title="9">{
        if ruleSet.parent != nil </span><span class="cov1" title="2">{
                label := ruleSet.label

                if label == "" </span><span class="cov1" title="1">{
                        if ruleSet.rule != nil </span><span class="cov1" title="1">{
                                label = ruleSet.rule.String()
                        }</span>
                }

                <span class="cov1" title="2">return ruleSet.parent.String() + "." + label</span>
        }

        <span class="cov3" title="7">return ruleSet.inner.String() + ".Any()"</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
